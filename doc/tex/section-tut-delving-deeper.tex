
% --------------------------------------------------------------------------------
\subsection{Preface}
\cutdef*{subsubsection}
\label{section:tut:delving:preface}


\begin{quote}\begin{tiny}
       ``Do what you love.  It works.  Trust me.''\newline
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~---{\em George Burns}
\end{tiny}\end{quote}

In this section we will begin delving into material which may be 
less familiar to the Perl/Python/Ruby programmer.  Do not be 
discouraged if you find it slower going than the previous section.

\cutend*

% --------------------------------------------------------------------------------
\subsection{NULL Values and THE}
\cutdef*{subsubsection}

In C it is common for functions to return {\sc NULL} when 
a valid pointer value is not possible.  Failure to check 
for {\sc NULL} pointers is a major source of program crashes.

Mythryl has a similar convention, except that the compiler 
implements compiletime checks sufficient to guarantee that 
you will never have a runtime crash due to lack of {\sc NULL} 
pointer checking.

Function results are wrapped using {\tt THE} if they are not {\tt NULL}. 
The two possibilities are then distinguished using a {\tt case}.  When 
you are sure a value is non-{\tt NULL}, you may use the function {\tt the} 
to strip off the {\tt THE}:

\begin{verbatim}
    #!/usr/bin/mythryl

    fun safe_divide i j:  Null_Or( Int )
        =
        if (j != 0)   THE (i / j);
        else          NULL;
        fi; 

    fun test i j
        =
        case (safe_divide i j)
            THE k => printf "%d / %d == %d\n" i j k; 
            NULL  => printf "You can't divide %d by %d!\n" i j;
        esac; 

    test 4 2;
    test 4 0;

    printf "6 / 3 == %d\n" (the (safe_divide 6 3));
    printf "6 / 0 == %d\n" (the (safe_divide 6 0));
\end{verbatim}

When run this will yield:

\begin{verbatim}
    linux$ ./my-script
    4 / 2 == 2
    You can't divide 4 by 0!
    6 / 3 == 2

    Uncaught exception NULL_OR
\end{verbatim}


\cutend*

% --------------------------------------------------------------------------------
\subsection{Tuples and Records}
\cutdef*{subsubsection}

"Tuple" is a mathematical word for a sequence of values.  It is a 
generalization of such English words as:

\begin{verbatim}
   "duple"     (two of something),
   "triple"    (three ...       ),
   "quadruple" (four  ...       )
   "quintuple" (five  ...       )
   "sextuple"  (six   ...       )
   "septuple"  (seven ...       )
   "octuple"   (eight ...       )
\end{verbatim}

We use "tuple" to refer to all of these plus all other lengths.

Mythryl tuples are written with the values wrapped in parentheses 
and separated by commas:

\begin{verbatim}
    ("this", 123)             # A length-two tuple.
    (0, 1, "infinity")        # A length-three tuple.
    ("string", 'a', 1, 1.0)   # A length-four tuple.
\end{verbatim}

Tuples are near and dear to Mythryl's heart.  They are the cheapest, 
simplest compound datastructure, the material from which almost all 
else is fashioned.

In more formal language, a Mythryl tuple is a heterogeneous collection 
of values stored contiguously in a small chunk of memory and accessed 
by slot number.  Mythryl attempts to make creation of tuples as cheap 
as possible.  The Mythryl implementation can create tuples roughly as 
cheaply as C can push a stackframe.

\begin{verbatim}
    linux$ my

    eval:  a = ("Windward Passage", 13.5, 9318.0);

    eval:  #1 a;
    "Windward Passage"

    eval:  #2 a;
    13.5

    eval:  #3 a;
    9318
\end{verbatim}

A Mythryl record is similarly a heterogeneous collection of values stored 
contiguous in a small chunk of memory.  The difference is that record values 
are accessed by name instead of by slot number:

\begin{verbatim}
    linux$ my

    eval:  a = { name => "Windward Passage", length_overall => 13.5, displacement => 9318.0 }; 

    eval:  a.name;
    "Windward Passage"

    eval:  a.length_overall;
    13.5

    eval:  a.displacement;
    9318.0

    eval:  .name a;
    "Windward Passage"

    eval:  .length_overall a;
    13.5

    eval:  .displacement a;
    9318.0
\end{verbatim}

As the above example shows, record fields can be accessed by name via 
the {\tt record.field} syntax familiar from C.  This is usually the 
most readable syntax.

The final three expressions in the above example show that record 
fields can also be accessed by applying the fieldname as a function.

This may be useful, for example, in conjunction with {\tt map}, 
extracting a given field from a list of records:

\begin{verbatim}
    eval:  a = { name => "Windward Passage", length_overall => 13.5,  displacement =>   9318.0 };
    eval:  b = { name => "Gay Deceiver",     length_overall => 130.5, displacement => 491634.8 };

    eval:  c = [ a, b ];

    eval:  map .name c;
    ["Windward Passage", "Gay Deceiver"]

    eval:  map .length_overall c;
    [13.5, 130.5]

    eval:  map .displacement c;
    [9318.0, 491634.8]
\end{verbatim}

Value order is significant in a tuple: {\tt (1,2,3)} is not the 
same tuple as {\tt (3,2,1)}.

Field order within a record, by contrast, is of no signficance: 
{\tt \{ first=>"John", last=>"Doe" \}} is exactly equivalent to 
{\tt \{ last=>"Doe", first=>"John" \}}.

Semantically, Mythryl records and tuples are very closely related.  In 
fact, internally, the Mythryl compiler converts record expressions 
into tuple expressions very early in processing and makes no 
distinction between them thereafter.

Whether to use tuples or records in a given situation is thus often more 
a matter of taste than anything else.

Records and tuples are the cheapest, simplest Mythryl datastructures. 
They are the bricks and mortar from which higher level datastructures 
are built.

Mythryl programs create and discard 
enormous numbers of tuples and records as they run.  Mythryl makes creating 
them as cheap as pushing a stackframe in C;  it is expected and encouraged 
that the Mythryl programmer think as little of creating a new tuple or 
record as does the C programmer of doing a function call.

As the above examples hint, tuples and records are particularly 
powerful in combination with lists.  Lists excel at handling 
variable-length homogeneous collections; records and tuples excel at 
handling fixed-length heterogeneous collections.

\cutend*


% --------------------------------------------------------------------------------
\subsection{Vectors}
\cutdef*{subsubsection}
\label{section:tut:delving-deeper:vectors}

Vectors and arrays are the heart and soul of languages like Fortran.  Open up 
any Fortran source file at random, and you will probably be looking at a 
{\tt do} loop over a vector or array.  Fortran compiler writers sweat blood 
trying to squeeze one percent more performance out of such loops.

Mythryl is not like that.  The heart and soul of Mythryl is recursive processing 
of recursive datastructures like lists.  Mythryl compiler writers sweat blood 
trying to squeeze a little more performance out of such recursive functions. 

But Mythryl does have vectors, and occasionally they are just the right tool 
for the job.

The fundamentally interesting properties of vectors are:

\begin{itemize}
\item They are cheap.
\item They allow constant-time access to any element by postion.
\end{itemize}

Accessing the one-hundredth element in a list requires one hundred operations, 
stepping down the list, but accessing the one-hundredth element in a vector takes 
no longer than accessing the first element.

Vectors are like tuples in that they efficiently store a sequence of elements 
which may be accessed by slot number.  The crucial difference is that tuple 
elements may be of different types, and tuple slots may be accessed using 
only constant slot numbers, whereas vector elements must all be of the same 
type, and may be fetched using slot index variables as well as slot index 
constants.

The fundamental operations of interest on vectors are 
\begin{itemize}
\item Create.
\item Get {\it i}--th element.
\item Get length.
\end{itemize}

Here is a transcript of creating a three-element vector, accessing 
each of its elements, and then getting its length:

\begin{verbatim}
    linux$ my

    eval:  v = #[ 11, 22, 33 ];
    #[11, 22, 33]

    eval:  v[ 0 ];
    11

    eval:  v[ 1 ];
    22

    eval:  v[ 2 ];
    33

    eval:  vector::length v;
    3
\end{verbatim}

Mythryl vectors are type-agnostic (``{\it polymorphic}'' --- literally, ``many shaped''):  They may 
contain elements of any type, so long as all the elements of a given vector 
are the same type.  Here is the above example repeated with a vector of Strings: 

\begin{verbatim}
    linux$ my

    eval:  v = #[ "one", "two", "three" ];
    #["one", "two", "three"]

    eval:  v[ 0 ];
    "one"

    eval:  v[ 1 ];
    "two"

    eval:  v[ 2 ];
    "three"

    eval:  vector::length v;
    3
\end{verbatim}

You will often wish to construct a vector from elements computed on 
the fly at runtime.  Most frequently you will have accumulated these 
in a list while computing them.  The {\tt vector::from\_list} function 
does what you need in this case:

\begin{verbatim}
    linux$ my

    eval:  v = vector::from_list (reverse( [ "one", "two", "three" ] ) );
    #["three", "two", "one"]
\end{verbatim}

Another frequent operation is to apply some function to all the elements 
of a vector and return a vector containing the results --- the vector 
equivalent of the list {\tt map} function.  Here is an example where we 
add one to each element of a vector:

\begin{verbatim}
    linux$ my

    eval:  v = vector::from_list (1..10);
    #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    eval:  w = vector::map  (\\ i = i + 1)  v;
    #[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
\end{verbatim}

The {\tt vector::apply} function is just like the {\tt vector::map} function 
except that no result value is constructed.  It is useful when we are applying 
a function to the vector elements purely for its side effects:

\begin{verbatim}
    linux$ my

    eval:  v = #[ "q", "w", "e", "r", "t", "y" ];
    #["q", "w", "e", "r", "t", "y"]

    eval:  vector::apply print v;
    qwerty
\end{verbatim}

If you are in a C-flavored frame of mind, you can do the same 
thing with an explicit {\tt for} loop:

\begin{verbatim}
    #!/usr/bin/mythryl

    v = #[ "q", "w", "e", "r", "t", "y" ];

    for (i = 0;  i < vector::length v;  ++i) {
        print v[i];
    };

    print "\n";
\end{verbatim}

Running the above yields:

\begin{verbatim}
    linux$ ./my-script
    qwerty
    linux$
\end{verbatim}


The {\tt v[i]} notation for accessing the {\it i}-th element of a vector 
is readable for general use, but a nuisance if you want to pass the 
vector-get function around as an argument, say to use it in conjunction with 
functions like {\tt map}.  For cases like this, the vector-get operation 
is also available as {\tt vector::get}:

\begin{verbatim}
    linux$ my

    eval:  v = vector::from_list (shuffle (1..10));
    #[10, 9, 8, 3, 4, 5, 6, 7, 2, 1]

    eval:  vector::get (v, 0);
    10
\end{verbatim}

A final useful function is {\tt vector::set}.  This constructs a new 
vector which differs from a pre-existing vector in one specified slot:

\begin{verbatim}
    linux$ my

    eval:  v = #[ 3, 1, 4, 1, 6 ];             # Make a vector.
    #[3, 1, 4, 1, 6]

    eval:  w = vector::set( v, 1, 222 );       # Make a new vector differing in one slot.
    #[3, 222, 4, 1, 6]

    eval:  v;                                  # The original vector is unchanged.
    #[3, 1, 4, 1, 6]
\end{verbatim}


A number of other convenience operations are predefined on vectors, 
which we will cover in a later tutorial (peek at \ahrefloc{api:Vector}{Vector} 
if impatient), but 
the above is enough to get started with vanilla Vectors.

The other major vector flavor is Rw\_Vector.

Vanilla vectors are {\it immutable}.  Once created, they cannot be changed. 
Some people call such values {\it pure}.  Values which can be changed after 
creation via side-effects are termed {\it mutable} or {\it impure}.

Mythryl programmers work with pure values when they can and impure values 
when they must.

Pure values result in code which is much easier to understand, since 
you never have to worry about pure values changing in unexpected ways 
at inconvenient moments, due perhaps to other threads running on other 
cores.

But sometimes you really do need to to modify the an existing value, 
perhaps because the algorithm requires it ({\it e.g.} many matrix algorithms), 
perhaps because you are precisely interested in broadcasting information 
to other threads in a multithread program.

For such cases Mythryl provides Rw\_Vectors, which as the name suggests are 
writable as well as readable.

The \ahrefloc{api:Rw\_Vector}{Rw\_Vector api} is almost identical to the 
\ahrefloc{api:Vector}{Vector api};  the significant difference is just that the 
{\tt rw\_vector::set} operation modifies its argument vector in place:

\begin{verbatim}
    linux$ my

    eval:  v = rw_vector::from_list [ 3, 1, 4, 1, 6 ];
    [|3, 1, 4, 1, 6|]

    eval:  rw_vector::set( v, 1, 222 );
    ()

    eval:  v;
    [|3, 222, 4, 1, 6|]
\end{verbatim}

We will have more to say about vectors \ahrefloc{section:tut:full-monte:typelocked-vectors}{later}, 
but first it is time to discuss {\it pattern matching}.

\cutend*


% --------------------------------------------------------------------------------
\subsection{Pattern Matching}
\cutdef*{subsubsection}

In many languages, exchanging the values of two variables is an 
ugly if simple chore requiring resort to a temporary variable.  In 
C, for example, we might have something like

\begin{verbatim}
    {   int i = 12;
        int j = 13;
        ...
        /* Need to swap i with j now: */
        {   int temp = i;
            i = j;
            j = temp;
        }
        ...
    }
\end{verbatim}

A few languages have a special hack which lets you do something like that in 
one line.  Mythryl has something which looks like one of those hacks:

\begin{verbatim}
    linux$ my

    eval:  i = 12;
    eval:  j = 13;

    eval:  my (j,i) = (i,j);

    eval:  i;
    13

    eval:  j;
    12
\end{verbatim}

But in Mythryl, this is not a special-case hack, but rather a specific application 
of a pervasive facility known as {\it pattern matching}.

Consider the typical Perl subroutine prologue, which looks something like this: 

\begin{verbatim}
    sub mumble {
        local( $arg1, $arg2, $arg3 ) = @_;
        ...
    }
\end{verbatim}

The {\tt local} statement above is unpacking the anonymous vector {\tt \verb|@_|} into 
three local variables {\tt \$arg1}, {\tt \$arg2}, {\tt \$arg3}.  It is doing 
three assignments in one line.  This notation is admirably economical!

Mythryl allows similar parallel assignments in a very general and flexible way.

Here is an example of unpacking a three-slot tuple into three variables:

\begin{verbatim}
    linux$ my
    eval:  x = (1,2,3);

    eval:  my (a,b,c) = x;

    eval:  a;
    1

    eval:  b;
    2

    eval:  c;
    3
\end{verbatim}

Here is a matching example of unpacking a three-field record into three variables:

\begin{verbatim}
    eval:  x = { name => "John Doe", height => 2.0, weight => 100.0 };

    eval:  my { name => a, height => b, weight => c } = x;

    eval:  a;
    "John Doe"

    eval:  b;
    2.0

    eval:  c;
    100.0
\end{verbatim}

In practice, one frequently unpacks the record into variables with the 
same names as the record fields:

\begin{verbatim}
    eval:  x = { name => "John Doe", height => 2.0, weight => 100.0 };

    eval:  my { name => name, height => height, weight => weight } = x;

    eval:  name;
    "John Doe"

    eval:  height;
    2.0

    eval:  weight;
    100.0
\end{verbatim}

In cases like this, the redundancy of an expression like

\begin{verbatim}
    my { name => name, height => height, weight => weight } = x;
\end{verbatim}

can quickly become annoying, so Mythryl allows one to simply 
drop the variable name in such cases;  if it is not given, Mythryl 
assumes it is the same as the field name:

\begin{verbatim}
    eval:  x = { name => "John Doe", height => 2.0, weight => 100.0 };

    eval:  my { name, height, weight } = x;

    eval:  name;
    "John Doe"

    eval:  height;
    2.0

    eval:  weight;
    100.0
\end{verbatim}

This code idiom is used pervasively in Mythryl code.

Similar comments apply in the reverse direction, when 
constructing records.  It is very common to accumulate values one by 
one in local variables and then construct a record when all values 
are in hand:

\begin{verbatim}
    eval:  a = "John Doe";
    eval:  b = 2.0;
    eval:  c = 100.0;

    eval:  x = { name => a, height => b, weight => c };

    { height=2.0, name="John Doe", weight=100.0 }
\end{verbatim}

Once again, it is very common to accumulate the values in variables 
with the same names as the field-names in the record:

\begin{verbatim}
    eval:  name = "John Doe";
    eval:  height = 2.0;
    eval:  weight = 100.0;

    eval:  x = { name => name, height => height, weight => weight };
    { height=2.0, name="John Doe", weight=100.0 }
\end{verbatim}

Once again, repeating every identifier twice during construction of the 
record quickly becomes tedious, so Mythryl allows dropping the variable 
name in such cases:

\begin{verbatim}
    eval:  name = "John Doe";
    eval:  height = 2.0;
    eval:  weight = 100.0;

    eval:  x = { name, height, weight };
    { height=2.0, name="John Doe", weight=100.0 }
\end{verbatim}

This is another idiom used pervasively in Mythryl code.

Let us return to the topic of pattern matching.

One frequently wishes to extract only a subset of the values in a 
tuple.  In this case one uses underbar wildcards in the slots which 
are not of interest:


\begin{verbatim}
    eval:  x = (1,2,3,4,5,6);
    eval:  my (a,_,c,_,d,_) = x;

    eval:  a;
    1

    eval:  c;
    3

    eval:  d;
    5
\end{verbatim}

This is yet another pervasive idiom.

To make things more interesting, Mythryl also allows tuples and records to 
be nested arbitrarily in patterns:

\begin{verbatim}
    eval:  x = ( 1, (2,3), { name=>"John Doe", height => 2.0, weight => 100.0 } );

    eval:  my (_, (_, a), { name,  ... } ) = x;

    eval:  a;
    3

    eval:  name;
    "John Doe"
\end{verbatim}

Here we have a tuple containing another tuple plus a record;  we 
have extracted one value each from the nested tuple and record, 
using a {\tt ... } elipsis to represent the record fields in which 
we have no interest and underbar wildcards to represent the tuple 
slots in which we have no interest.

Pattern matching pops up in Mythryl in all sorts of spots in which 
you might not at first expect it.  For example, the rules in 
{\tt case} statements allow pattern-matching:

\begin{verbatim}
    #!/usr/bin/mythryl

    x = (1, (2,3));

    case x
    (1, (b, c)) => printf "one-tuple carrying %d %d\n" b c;
    (a, (b, c)) => printf "%d-tuple carrying %d %d\n" a b c;
    esac;
\end{verbatim}

When run, this produces

\begin{verbatim}
    linux$ ./my-script
    one-tuple carrying 2 3
    linux$ 
\end{verbatim}

When interpreting such case statements it is important to remember 
that they are logically evaluated by the compiler top to bottom, 
selecting the first one which matches.  (In practice, the compiler 
uses sophisticated optimization techniques to speed execution.) 

As the patterns used in such rules become more complex, it becomes 
ever more reassuring that the compiler issues diagnostics for rules 
which are redundant (can never match) and rulesets which are 
incomplete (some possible inputs would match no rule).

The {\tt case} statement pattern matching facility can be used in 
some interesting and initially non-obvious ways.  Suppose for 
example that one has two Boolean variables and needs to execute 
different code for all four possible combinations of their values. 
One could nest multiple {\tt if} statements, but this is cleaner:

\begin{verbatim}
    #!/usr/bin/mythryl

    a = TRUE;
    b = FALSE;

    case (a,b)
    (TRUE, TRUE ) => print "TRUE / TRUE  case\n";
    (TRUE, FALSE) => print "TRUE / FALSE case\n";
    (FALSE,TRUE ) => print "FALSE/ TRUE  case\n";
    (FALSE,FALSE) => print "FALSE/ FALSE case\n";
    esac;
\end{verbatim}

\begin{verbatim}
    linux$ ./my-script
    TRUE / FALSE case
    linux$ 
\end{verbatim}

In this particular case the benefit is small, but as the 
number of states to be enumerated grows larger, so does 
the improvement in code readability and maintainability 
relative to using a rats-nest of {\tt if} statements.


\cutend*

% --------------------------------------------------------------------------------
\subsection{Mutually Recursive Functions and Datastructures}
\cutdef*{subsubsection}

A C {\tt enum} declaration allows definition of a data type consisting 
of a finite list of alternatives:

\begin{verbatim}
    enum Color { RED, GREEN, BLUE };
\end{verbatim}

The {\tt enum} declaration is not particularly near and dear to the 
C programmer's heart.  In fact, the {\tt enum} declaration was not 
even mentioned in {\it The C Programming Language}.

Mythryl has a similar construct:

\begin{verbatim}
    Color = RED | GREEN | BLUE;
\end{verbatim}

This construct is however very near and dear indeed to the heart of 
the Mythryl programmer;  it is the rock upon which mutually recursive 
datastructures are built, which are in turn the backbone of  
sophisticated programs such as the Mythryl compiler itself.

Simple declarations such as the above one are frequently used to define 
a data type which can then be used in records:

\begin{verbatim}
    #!/usr/bin/mythryl

    Color  = BLUE | GREEN | RED;

    fun print_color( color ) = {
        case color
            RED   => print "Red\n";
            GREEN => print "Green\n";
            BLUE  => print "Blue\n";
        esac;
    };

    a = { x => 1.0, y => 1.0, diameter => 0.5, color => RED  };
    b = { x => 1.0, y => 2.0, diameter => 0.7, color => BLUE };

    print_color(a.color);
    print_color(b.color);
\end{verbatim}

The {\tt a} and {\tt b} records above might represent circles to be 
drawn upon the screen in a graphics application, say.

One nice aspect of code such as the above is that if {\tt Color} is 
redefined to include one more (or less) color, the compiler will 
automatically flag all {\tt case} statements on {\tt Color} which have not 
been modified appropriately to reflect the new definition.  This 
can be an enormous help when maintaining large complex programs. 
(Relative to doing the same thing in C, say.)

However, the real power of such declarations only begins to become 
apparent when the named constants are decorated with data values:

\begin{verbatim}
    #!/usr/bin/mythryl

    Tree = LEAF(Int)
         | NODE { key: Int, left_kid: Tree, right_kid: Tree };

    fun print_tree( t ) = {

        case t

            LEAF i => printf "leaf: %d\n" i;

            NODE { key, left_kid, right_kid }
                =>
                {   print_tree(left_kid);
                    printf "key: %d\n" key;
                    print_tree(right_kid);
                };

        esac;
    };

    my_tree = NODE { key => 2, left_kid => LEAF 1, right_kid => LEAF 3 };

    print_tree(my_tree);
\end{verbatim}

Running the above will produce:

\begin{verbatim}
    linux$ ./my-script
    leaf: 1
    key: 2
    leaf: 3
\end{verbatim}

Now, there's a lot going on there!  If you translated the above into 
C or Java, you would probably have several pages of code.  Let's break 
it down:

\begin{verbatim}
    Tree = LEAF(Int)
         | NODE { key: Int, left_kid: Tree, right_kid: Tree };
\end{verbatim}

This two-liner defines a complete binary tree data type. 

The first line says that leaf nodes carry a single integer value. 

The second line says that internal nodes carry a record containing an integer 
key and pointers to two subtrees.  (Mythryl does not distinguish between 
record values and pointers to records the way C does.  Think of it as 
always implementing the pointer case.)

Since the definition of the {\tt Tree} type refers to itself (the 
record fields {\tt left\_kid} and {\tt right\_kid} are both of type 
{\tt Tree}), it defines a recursive datastructure, instances of which may be 
arbitrarily large.

Now consider the function definition:

\begin{verbatim}
    fun print_tree( t ) = {

        case t

            LEAF i => printf "leaf: %d\n" i;

            NODE { key, left_kid, right_kid }
                =>
                {   print_tree(left_kid);
                    printf "key: %d\n" key;
                    print_tree(right_kid);
                };
        esac;
    };
\end{verbatim}

The {\tt case} expressions 
{\tt LEAF i} and {\tt NODE \{ key, left\_kid, right\_kid \}} 
are again examples of pattern-matching assignments.

This recursive routine takes a single argument.

If that argument is a {\tt LEAF}, it simply prints out the integer 
value associated with the leaf, pattern-matched out of the 
left hand side of the rule.

If that argument is an internal binary tree {\tt NODE}, it does 
an in-order traversal, recursively printing out its left 
subtree, then printing out its key, then again 
recursively printing out its right subtree.

Finally, consider the statement

\begin{verbatim}
    my_tree = NODE { key => 2, left_kid => LEAF 1, right_kid => LEAF 3 };
\end{verbatim}

This statement constructs a complete (little) binary tree consisting of 
two leaf nodes and one internal node.  (Don't try doing this in one 
line in C!)

In this context the constants {\tt NODE} and {\tt LEAF} are called 
{\it constructors}, for the simple and sufficient reason that when 
they are applied as functions they construct values 
of the indicated type.

Having these constructors implicitly generated by the Mythryl compiler 
in response to the {\tt Tree} type declaration is one of the things 
that makes Mythryl code so economical.

As the final major twist to this story, Mythryl allows us to define 
mutually recursive datastructures.  Suppose, for example, we are 
building a {\it mud} --- an online interactive text game in which players 
wander through rooms connected by doors.  Each room may have 
multiple doors, and each door connects the current room to 
another room:

\begin{verbatim}
    #!/usr/bin/mythryl

    Room = ROOM { name: String, description: String, doors: List(Door) }
    also
    Door = DOOR { name: String, description: String, to: Room };

    fun print_room( ROOM { name, description, doors } ) = {
        printf "%s room: You see %s\n" name description;
        apply print_door doors; 
    }
    also
    fun print_door( DOOR { name, description, to } ) = {
        printf "%s door: You see %s\n" name description;
        print_room to;
    };

    level = ROOM { name => "main",
                   description => "a big entryroom.", 
                   doors => [  DOOR { name => "kitchen.",
                                      description => "a white door.",
                                      to => ROOM { name => "kitchen", 
                                                   description => "a tidy kitchen.",
                                                   doors => []
                                                 }
                                    }
                            ] 
                   };

    print_room level;
\end{verbatim}

The {\tt Room} and {\tt Door} types are mutually recursive.  Naturally, 
this means that to process the resulting data structure we need 
mutually recursive functions, in this case {\tt print\_room} and {\tt print\_door}.

In both cases we use the {\tt also} 
reserved word to notify the compiler 
of the mutual recursion.

Notice in each case the absence of a semicolon 
preceding the {\tt also}.  Mythryl ends complete statements 
with a semicolon, and only complete statements.

Here we also see for the first time that function call parameter lists 
do pattern-matching.  We use this facility in both the {\tt print\_door} 
and {\tt print\_room} functions to efficiently unpack the values we 
need from the relevant record structures.

When run, the above script produces

\begin{verbatim}
    linux$ ./my-script
    main room: You see a big entryroom.
    kitchen door: You see a white door.
    kitchen room: You see a tidy kitchen.
\end{verbatim}

That's not much as muds go, but that's a lot accomplished in half a 
page of code!  If you coded up the same thing in C you might have 
five or ten pages of code before you were done.

\cutend*


% --------------------------------------------------------------------------------
\subsection{List Comprehensions}
\cutdef*{subsubsection}
\label{section:tut:delving-deeper:list-comprehensions}

You may be familiar from mathematics with notations such as 
$\{ i^{2} | 0 < i < 100, i \epsilon Primes \}$ for the set 
containing the squares of all primes less than one hundred. 
This notation is technically termed a {\it set comprehension}. 

A similar notation inspired by set comprehensions has recently 
become popular in programming languages ranging from Python to 
Ocaml.  They define ordered lists rather than unordered sets, 
and are consequently termed {\it list comprehensions}.

Here is the Mythryl list comprehension corresponding to the 
above set comprehension:

\begin{verbatim}
    linux$ my

    eval:  [ i*i for i in (1..99) where isprime i ];

    [1, 4, 9, 25, 49, 121, 169, 289, 361, 529, 841, 961, 1369, 
     1681, 1849, 2209, 2809, 3481, 3721, 4489, 5041, 5329, 6241, 
     6889, 7921, 9409]

\end{verbatim}

List comprehensions provide a compact, convenient way of generating 
lists of interesting values.  Without list comprehensions, we would 
instead have had to write something like

\begin{verbatim}
    loop (1..99, [])
    where
        fun loop ([], results)
                =>
                reverse results;

            loop (i ! rest, results)
                =>
                loop
                  ( rest,

                    isprime i   ??   i*i ! results
                                ::         results
                  );
        end;                
    end;                
\end{verbatim}

The underlying list comprehension syntax used above is

\begin{quotation}
~~~~[ {\it result-expression} {\bf for} {\it pattern} {\bf in} {\it list-expression} {\bf where} {\it condition} ];
\end{quotation}

where
\begin{itemize}
\item {\it list-expression} is any Mythryl expression yielding a list;
\item {\it pattern} is any Mythryl pattern which will match the members of that list;
\item {\it condition} is any Mythryl Boolean expression selecting list elements;
\item {\it result-expression} is any Mythryl expression over the values in {\it pattern}.
\end{itemize}

In general there may be multiple {\tt for} clauses, and the {\tt where} clause 
is optional:

\begin{verbatim}
    linux$ my

    eval:  [ (i,j)  for i in (0..4)  for j in (5..9) ];

    [ (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (1, 5), 
      (1, 6), (1, 7), (1, 8), (1, 9), (2, 5), (2, 6), 
      (2, 7), (2, 8), (2, 9), (3, 5), (3, 6), (3, 7), 
      (3, 8), (3, 9), (4, 5), (4, 6), (4, 7), (4, 8), 
      (4, 9) ]

\end{verbatim}

Here is an example of finding Pythagorean triples --- sets 
of three integers which could be the lengths of the sides of a 
right triangle:

\begin{verbatim}
    linux$ my

    eval:  [ (x,y,z) for x in 1..20 for y in x..20 for z in y..20 where x*x + y*y == z*z ];

    [ (3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15), (12, 16, 20)]
\end{verbatim}

To show that list comprehensions are useful for 
more than just playing with numbers, here is an example 
more relevant to system administration. 
This one creates a list of {\tt (filename, filesize)} pairs 
for all {\tt .pkg} files under the current directory:

\begin{verbatim}
    linux$ my

    eval:  [ (filename, (stat filename).size) for filename in dir_tree::files "." where filename =~ ./\\.pkg$/ ];

    [ ("/pub/home/cynbe/a/foo.pkg", 451), 
      ("/pub/home/cynbe/a/bar.pkg", 910) ]
\end{verbatim}

(For the curious, Mythryl list comprehensions are implemented primarily by 
\ahrefloc{src/lib/compiler/front/parser/raw-syntax/expand-list-comprehension-syntax.pkg}{src/lib/compiler/front/parser/raw-syntax/expand-list-comprehension-syntax.pkg}.)

\cutend*


% --------------------------------------------------------------------------------
\subsection{Code Reading Interlude}
\cutdef*{subsubsection}

Nobody ever became a great writer without reading the works 
of previous great writers, or a great composer without hearing 
the works of previous great composers;  is it not odd that 
programming classes devote so little attention to reading the 
works of great programmers?

It is this sort of failure to build upon the achievements of our 
predecessors which 
\ahref{\richardhamming}{Richard Hamming} had in mind when he said 
only half-jokingly:

\begin{quote}
       ``Mathematicians stand on each other's shoulders while computer scientists stand on each other's toes.''\newline
\end{quote}

To learn programming you should spend lots of  
time hands-on crafting code, but you should also spend 
lots of time reading major programs by major programmers.

I know I learn something new every time I do that!

With this thought in mind, the Mythryl {\sc HTML} documentation 
includes the entire Mythryl platform codebase, both compiler and 
libraries, heavily hyperlinked to encourage casual code surfing.

This is a good time to make a first foray into that codebase. 
You now know enough Mythryl to get at least a general sense 
of what the code is doing, and skimming some industrial-scale 
code will do wonders for building up your Mythryl coding 
intuition and esthetic sense.

You may see industrial-scale examples of defining Mythryl mutually 
recursive datastructures in the files which define the Mythryl compiler  
raw and deep syntax trees.

You should not expect --- or even try --- to understand them in detail 
at this point, you should just try to skim lightly 
to get a bit of a feel for the flavor of production Mythryl code:

\begin{itemize}
\item \ahrefloc{src/lib/compiler/front/parser/raw-syntax/raw-syntax.api}{src/lib/compiler/front/parser/raw-syntax/raw-syntax.api}.
\item \ahrefloc{src/lib/compiler/front/typer-stuff/deep-syntax/deep-syntax.api}{src/lib/compiler/front/typer-stuff/deep-syntax/deep-syntax.api}.
\end{itemize}

For a matching peek at actual processing of such datastructures, you might 
look at some of the Mythryl raw syntax tree unparsing or typechecking code:

\begin{itemize}
\item \ahrefloc{src/lib/compiler/front/typer/print/unparse-raw-syntax.pkg}{src/lib/compiler/front/typer/print/unparse-raw-syntax.pkg}.
\item \ahrefloc{src/lib/compiler/front/typer/main/type-core-language.pkg}{src/lib/compiler/front/typer/main/type-core-language.pkg}.
\end{itemize}

\cutend*


% --------------------------------------------------------------------------------
\subsection{Exceptions}
\cutdef*{subsubsection}

Most modern languages have some sort of mechanism for aborting 
a subcomputation which has gone seriously wrong and picking up 
again at an appropriate recovery point.

For example C has {\tt setjmp()} and {\tt longjmp()} and Python 
has {\tt try: ... except SomeError: ... }.

Mythryl has a facility which is quite similar in function and 
application, albeit with some interesting twists.

The Mythryl exception handling machinery consists of three 
fundamental parts:
\begin{itemize}
\item An {\it exception} data type and matching {\tt exception} declaration.
\item An {\tt except} statement for trapping exceptions.
\item A {\tt raise exception} statement for raising exceptions.
\end{itemize}

A typical use might look something like:

\begin{verbatim}
    fun foo ()
        =
        {   exception FOUND_IT( Int );
            exception NOT_FOUND;

            fun do_deep_recursive_search ()
                =
                {    ...
                     raise exception NOT_FOUND;       # Oh well.
                     ...
                     raise exception FOUND_IT( n/32 + 6 );
                     ...
                };

            do_deep_recursive_search ()
            except
                NOT_FOUND   => printf "Could not find answer!\n";
                FOUND_IT(i) => printf "The answer is %d.\n" i;
            end;
        };
\end{verbatim}


Mythryl exceptions may carry arbitrary information.  They are 
defined via declarations like

\begin{verbatim}
    exception DISK_ERROR;
    exception OUT_OF_RAM;
    exception TERMINATED_BY_SIGNAL_FROM_PROCESS( Int   );       # Int value is pid of external process.
    exception VIOLATION_OF_ACCESS_CONTROL_RULE( String );       # String value is text of rule. 
\end{verbatim}

These declarations behave a lot like a vanilla 
sumtype declaration

\begin{verbatim}
    Exception = DISK_ERROR
              | OUT_OF_RAM;
              | TERMINATED_BY_SIGNAL_FROM_PROCESS( Int   );
              | VIOLATION_OF_ACCESS_CONTROL_RULE( String );
\end{verbatim}

The {\tt exception} declarations differ primarily in that 
constructors declared with {\tt exception} may be used as arguments to {\tt raise exception} and {\tt except}.

The Mythryl {\tt raise exception} construct is used to change the flow of control 
by activating the exception handling machinery. 
It is logically a lot like {\tt longjmp()} in C.

One difference is that the C {\tt longjmp()} function is not very 
efficient; the usual implementation has to sequentially search down 
the stack until it finds a registered {\tt setjmp()} handler. 
The Mythryl {\tt raise exception} construct, by contrast, is implemented very 
efficiently.  The mechanism used is essentially identical to that 
used to return from a Mythryl function call, and consequently 
executes just as quickly.  Mythryl {\tt raise exception} and {\tt except} 
are sometimes used as a simple non-local {\tt goto}, quite independently 
of any consideration of exceptional conditions.

The Mythryl {\tt except} construct is in essence a specialized 
{\tt case} statement.  Like function definitions, it has separate 
syntax for the single-alternative and multi-alternative cases:

\begin{verbatim}
    exception SOME_EXCEPTION; 
    exception EXCEPTION_ONE(String); 
    exception EXCEPTION_TWO(Float); 

    # Single-exception syntax:
    #
    some_expression ()
    except
        SOME_EXCEPTION = printf "Encountered SOME_EXCEPTION\n";

    # Multi-exception syntax:
    #
    some_expression ()
    except
        EXCEPTION_ONE(string) => printf "Encountered EXCEPTION_ONE(%s)\n" string;
        EXCEPTION_TWO(float)  => printf "Encountered EXCEPTION_TWO(%f)\n" float ;
    end;
\end{verbatim}

As always, the single-alternative form uses {\tt =} and has no {\tt end} while 
the multi-alternative form uses {\tt =>} and has an {\tt end} trailing the final 
alternative.
 
The Mythryl standard library \ahrefloc{pkg:safely}{safely} package provides 
canned functionality for protecting a computation from exceptions.  It is 
often used to, for example, read from a file while guaranteeing that the 
file will be closed properly should any exception be raised, by catching 
the exception, closing the file, and then re-raising the exception.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Side Effects}
\cutdef*{subsubsection}

It is time to broach the vexed subject of {\it side-effects}.

By {\it side-effects} in this context we mean essentially changing  
some value in memory in such a way that if code which had previously 
examined its value were to re-examine it, it would find that value 
changed.

Side-effects were not a major issue when the C programming 
language was designed.  Computers were slow, memories were small 
(often less then 64K of RAM), and consequently programs were small 
and simple.

Today it is common for commodity desktop computers to have 
gigabytes of memory and multiple cores executing instructions 
in parallel out of that memory.  Hundreds of millions of lines 
of code may be executing in-memory at the same time.  On high-end 
number-crunching computers there may be tens of thousands of cores.

In this regime side-effects {\it are} a major issue.

From a hardware design point of view, every side-effect is now in fact 
a broadcast operation: The results of that memory write may need to be 
made visible to anything from four to eight cores on a small machine 
to tens of thousands of cores on a supercomputer.  That is an 
inherently slow and expensive operation.  The more side-effects the 
program creates, the harder it will be to attain good execution speed.

From a software design point of view, in such a context every 
side-effect is a bug waiting to happen.  Side-effects are fertile 
breeding grounds for a wide variety of bugs ranging from race 
conditions to stale local copies.

In the contemporary context, thus, there are major advantages to 
software development approaches which avoid needless use of 
side-effects.


Some languages make pervasive use of side-effects.  In a C program 
often every other line of code will update a pre-existing 
record in memory and thus cause a side-effect.  Such languages are 
often called {\it imperative}.

Other languages, such as Haskell, completely ban side-effects. 
\ahref{\simonpeytonjones}{Simon Peyton-Jones} calls this {\it ``wearing the hair shirt''}.  Writing 
code completely without side-effects involves a number of severe 
difficulties --- and brings with it a number of great advantages. 
Such languages are often called {\it pure-functional}.

Mythryl belongs to the middle ground of {\it mostly-functional} 
languages.  Mythryl does allow side-effects, but typical Mythryl 
programs use them sparingly. The Mythryl compiler is 
tuned with the expectation that side-effects will be rare. 

Mythryl programs avoid side-effects by doing a lot of copying. 
Where a C program would update a record field in memory, a 
Mythryl program will typically just make a new, updated, copy of the 
record, leaving the original copy untouched.  Mythryl 
makes this very efficient;  Mythryl can create records 
in a fraction of the time needed by C.  (Is C faster than Mythryl? 
It depends what you measure!)

None of the Mythryl programs presented so far in these tutorials 
use side effects.

In fact, we have not yet presented any 
Mythryl language constructs which permit the creation of side 
effects.

Mythryl permits side-effects, but it places strong safeguards 
upon their use.

For example, all C record fields are read-write, permanently 
eligible to be modified in place.  (This creates hair-raising 
problems for C compiler writers attempting to optimize code.) 
But Mythryl record fields are read-only, permanently 
protected from modification, accidental or deliberate.

In Mythryl, in essence, only {\tt reference cells} may be 
modified.  All other values are read-only once created. 
(With the sole exception of mutable vectors.)

This enormously simplifies the compiler writer's job when 
implementing optimizations.

More importantly, it makes Mythryl code easier to understand.  There 
is never any question as to whether some function ten million lines 
away in another thread running on another core is about to update some 
value being used; with the exception of reference cells (and mutable 
vectors), such updates are forbidden.  This makes large Mythryl 
programs enormously easier to read and maintain than large C programs.

Mythryl reference cells are used much like C pointers, from 
a practical point of view:

\begin{verbatim}
    #!/usr/bin/mythryl

    pointer = REF 0;

    printf "%d\n" *pointer;

    pointer := 1;

    printf "%d\n" *pointer;

    pointer := 2;

    printf "%d\n" *pointer;
\end{verbatim}

Here one thinks of the {\tt REF} reference-creating operator much the way one 
thinks of the C {\tt \&} unary address-taking operator, 
and of the {\tt *pointer} dereferencing operator almost exactly the 
way one thinks of the corresponding C operator.

When run the above code produces

\begin{verbatim}
    0
    1
    2
\end{verbatim}

At first blush that may look a lot like this code:

\begin{verbatim}
    #!/usr/bin/mythryl

    variable = 0;

    printf "%d\n" variable;

    variable = 1;

    printf "%d\n" variable;

    variable = 2;

    printf "%d\n" variable;
\end{verbatim}

When run, the latter produces exactly the same output as the 
former.

The critical difference is that in the latter 
cases the {\tt =} ``assignments'' are only assigning convenient 
names to values.  It happens that the same name is being used 
several times, but nothing is actually being overwritten in 
any interesting sense.  No code running in another thread can 
ever observe {\tt variable} changing, and thus no timing 
bugs are possible as a result of the latter code executing.

In the former case, however, the {\tt REF} 
constructor allocates an actual shared cell in memory, and the 
{\tt :=} operator actually overwrites the contents of this 
cell.  We can store pointers to this cell in tuples and 
records and pass it around to other functions, which can 
then observe the changed value:

\begin{verbatim}
    #!/usr/bin/mythryl

    cell = REF 0;

    r0 = { name => "0", cell };
    r1 = { name => "1", cell };

    printf "*r0.cell == %d\n" *r0.cell;
    printf "*r1.cell == %d\n" *r1.cell;

    r0.cell := 1;

    printf "*r0.cell == %d\n" *r0.cell;
    printf "*r1.cell == %d\n" *r1.cell;

    r1.cell := 2;

    printf "*r0.cell == %d\n" *r0.cell;
    printf "*r1.cell == %d\n" *r1.cell;
\end{verbatim}

Running this produces:

\begin{verbatim}
    linux$ ./my-script
    *r0.cell == 0
    *r1.cell == 0
    *r0.cell == 1
    *r1.cell == 1
    *r0.cell == 2
    *r1.cell == 2
    linux$
\end{verbatim}

Notice that we are reading and writing the same cell through 
both the {\tt r0} and {\tt r1} records.  This sort of thing 
can {\it only} be done using {\tt REF} and {\tt :=}.

In general {\tt REF} and {\tt :=} should be viewed like {\tt goto} 
in C --- fundamentally regrettable and vaguely malevolent, but 
very occasionally exactly the right solution.

For example, {\tt REF} and {\tt :=} are indispensable when cyclic 
structures must be created.   In our pico-mud example in the 
previous section, it would be natural to have the {\tt Door} 
records point to both of the {\tt Room} objects they connect 
as well as having {\tt Room} objects point to all the {\tt Door}s 
entering and leaving them, but we were unable to do that because 
we had no way of forming cycles in a datastructure.

Here is an updated version which does use cyclic datastructures:

\begin{verbatim}
    #!/usr/bin/mythryl

    Room = ROOM { name: String, description: String, doors: Ref(List(Door)) }
    also
    Door = DOOR { name: String, description: String, from: Room, to: Room };

    fun print_room( self as ROOM { name, description, doors } ) = {
        printf "%s room: You see %s\n" name description;
        foreach *doors {.
            my door as DOOR { from, ... } = #d;
            if (from == self)  print_door door;  fi;            # Avoid going into an infinite loop!
        };
    }
    also
    fun print_door( DOOR { name, description, to, ... } ) = {
        printf "%s door: You see %s\n" name description;
        print_room to;
    };

    entryway = ROOM { name => "entryway", description => "a big entryway.", doors => REF [] };
    kitchen  = ROOM { name => "kitchen",  description => "a tidy kitchen.", doors => REF [] };

    door = DOOR { name => "kitchen", description => "a white door.", from => entryway, to => kitchen };

    my ROOM { doors => entryway_doors, ... } = entryway;   entryway_doors := [ door ];
    my ROOM { doors => kitchen_doors,  ... } = kitchen;    kitchen_doors  := [ door ];

    print_room  entryway;
\end{verbatim}

Here we have changed the {\tt doors} field to hold a reference to a list of doors --- 
which reference we can thus update.  This allows us to create both rooms first (with empty door lists), 
then create the door, with pointers to both rooms, and finally update the room door lists to 
include the door.

The above example also introduces the {\tt as} pattern-match syntax

\begin{verbatim}
    self as ROOM { name, description, doors }
\end{verbatim}

which allows us to assign a name {\tt self} to the 
entire room record even as we also assign names to its {\tt name}, {\tt description} 
and {\tt doors} individual fields.

When run, the above prints out

\begin{verbatim}
    linux$ ./my-script
    entryway room: You see a big entryway.
    kitchen door: You see a white door.
    kitchen room: You see a tidy kitchen.
    linux$
\end{verbatim}

\cutend*


% --------------------------------------------------------------------------------
\subsection{Balanced Binary Trees}
\cutdef*{subsubsection}
\label{section:tut:delving-deeper:balanced-binary-trees}

\subsubsection{Overview}
\cutdef*{paragraph}

A common programming operation is constructing a mapping from  
some set of keys to some set of corresponding values.  We might 
be mapping file names to file lengths or employee numbers to 
employee records or program variables to their types.  Abstractly, 
we are constructing a function which is defined by exhaustive 
enumeration rather than by any concise rule.

In this situation a Perl programmer would automatically reach for 
a hashtable.

A Mythryl programmer, however, will usually reach for a balanced 
binary tree.

Niklaus Wirth pointed out some years back that balanced binary trees 
are rarely the best-performing algorithm by a given measure, but they 
are usually in the top three or so by any given measure.  By contrast, 
the algorithm which places first by one measure will often place dead 
last by another.

For example, hashtables have an average access time of $O(1)$ with a 
very low proportionality constant;  they win hands-down by this 
measure.  But their worst case is a disastrous $O(N)$!  You would not 
want to use a hashtable in software controlling something like an 
airliner or nuclear reactor;  it might appear to work fine for years 
and then out of the blue stop dead due to an improbable series of 
hash bucket collisions.

For balanced binary trees, by contrast, the worst case $O(log(N)$, 
just the same as the best case.  Balanced binary trees are a tad 
slower than hashtables but rock-solid dependable.

Consequently using balanced binary trees is a very safe 
and sane habit;  they will never let you down.  Using 
hashtables, by contrast, is the kind of habit that is likely to get 
you killed some fine morning when you least expect it.

However, the Mythryl programmer's fondness for balanced binary trees 
goes much deeper than just their being a nice safe and sane datastructure.

A pervasive theme in Mythryl programming is avoiding the needless use 
of side-effects.  There is no practical way to update a hashtable 
without side effects: The entire table would have to be copied at 
each update, at prohibitive $O(N)$ cost. It is however perfectly practical 
to update balanced binary trees without side effects: 
By doing {\it path copying} when we update a balanced binary tree 
we can leave the original tree intact, simply building a new tree to 
replace it.  Sharing common parts between the old and new tree lets 
us do this quite efficiently, taking only $O(log(N))$ time and space. 

\cutend*
\subsubsection{Red-Black Trees}
\cutdef*{paragraph}


There are many flavors of balanced binary tree.  In general they are 
largely interchangeable;  the particular choice of tree seldom makes 
much difference.

The Mythryl codebase has settled on the \ahref{\wikipediaredblacktree}{Red-Black tree} 
as its standard flavor of balanced binary tree.  It contains a number 
of standard Red-Black tree implementations specialized to various needs, including: 
\begin{itemize}
\item \ahrefloc{src/lib/src/string-map.pkg}{src/lib/src/string-map.pkg}
\item \ahrefloc{src/lib/src/string-set.pkg}{src/lib/src/string-set.pkg}
\item \ahrefloc{src/lib/src/int-red-black-map.pkg}{src/lib/src/int-red-black-map.pkg}
\item \ahrefloc{src/lib/src/unt-red-black-set.pkg}{src/lib/src/unt-red-black-set.pkg}
\item \ahrefloc{src/lib/src/unt-red-black-map.pkg}{src/lib/src/unt-red-black-map.pkg}
\item \ahrefloc{src/lib/src/int-red-black-set.pkg}{src/lib/src/int-red-black-set.pkg}
\item \ahrefloc{src/lib/src/quickstring-red-black-map.pkg}{src/lib/src/quickstring-red-black-map.pkg}
\item \ahrefloc{src/lib/src/quickstring-red-black-set.pkg}{src/lib/src/quickstring-red-black-set.pkg}
\end{itemize}

The codebase also provides two generic packages which may be 
used to generate your own specialized Red-Black tree variants:

\begin{itemize}
\item \ahrefloc{src/lib/src/red-black-map-g.pkg}{src/lib/src/red-black-map-g.pkg}
\item \ahrefloc{src/lib/src/red-black-set-g.pkg}{src/lib/src/red-black-set-g.pkg}
\end{itemize}

More specialized Red-Black tree implementations include: 

\begin{itemize}
\item \ahrefloc{src/lib/src/red-black-numbered-set-g.pkg}{src/lib/src/red-black-numbered-set-g.pkg}
\item \ahrefloc{src/lib/src/red-black-numbered-list.pkg}{src/lib/src/red-black-numbered-list.pkg}
\item \ahrefloc{src/lib/src/red-black-tagged-numbered-list.pkg}{src/lib/src/red-black-tagged-numbered-list.pkg}
\end{itemize}

You do not need to understand the internals of these tree variants, but you 
will find it useful to know how to use the most common ones.

The Mythryl tree variants need to know how to compare their keys in order 
to keep the tree ordered, but they don't need to know anything about the 
values they are storing because they never do anything with them except 
accept and return them.  Consequently these trees are in general typeagnostic 
in their values but specialized to work with only one type of key.

\cutend*

\subsubsection{Red-Black Trees: String Keys}
\cutdef*{paragraph}

One frequently used tree variant is {\tt string\_map}, which may be used to 
maps strings to any sort of value desired, although in any single tree all 
values must be of the same type.

The typical pattern of usage is to create an empty tree, enter key-value pairs into 
it, and then retrieve the values by key.  Here is a simple script doing that with 
pairs where both key and value are strings.

Notice that when we create the empty 
map, we declare what type of value we intend to store in it.  This is not 
always necessary, but it is a good habit;  It helps both the compiler and 
the human reader.

Notice Also that since 
{\tt string\_map::get} returns either {\tt NULL} or else {\tt THE value} we use the 
{\tt the} function to drop the unwanted {\tt THE} from its return value:

\begin{verbatim}
    #!/usr/bin/mythryl

    m = (string_map::empty: string_map::Map( String ));

    m = string_map::set (m, "Key1", "Value1");
    m = string_map::set (m, "Key2", "Value2");
    m = string_map::set (m, "Key3", "Value3");

    printf "%s -> %s\n"  "Key1"  (the (string_map::get (m, "Key1")) );
    printf "%s -> %s\n"  "Key2"  (the (string_map::get (m, "Key2")) );
    printf "%s -> %s\n"  "Key3"  (the (string_map::get (m, "Key3")) );
\end{verbatim}

When run this yields just what you expect:
 
\begin{verbatim}
    linux$ ./my-script
    Key1 -> Value1
    Key2 -> Value2
    Key3 -> Value3
\end{verbatim}

Just to demonstrate the parametric polymorphism of the {\tt string\_map} tree 
in its values, here is the above example rewritten to use {\tt Int} values:

\begin{verbatim}
    #!/usr/bin/mythryl

    m = (string_map::empty: string_map::Map( Int ));

    m = string_map::set (m, "Key1", 111);
    m = string_map::set (m, "Key2", 222);
    m = string_map::set (m, "Key3", 333);

    printf "%s -> %d\n"  "Key1"  (the (string_map::get (m, "Key1")) );
    printf "%s -> %d\n"  "Key2"  (the (string_map::get (m, "Key2")) );
    printf "%s -> %d\n"  "Key3"  (the (string_map::get (m, "Key3")) );
\end{verbatim}

Execution of the script is again unsurprising:

\begin{verbatim}
    linux$ ./my-script
    Key1 -> 111
    Key2 -> 222
    Key3 -> 333
\end{verbatim}

Here is the same script rewritten yet again, this time to use float values:

\begin{verbatim}
    #!/usr/bin/mythryl

    m = (string_map::empty: string_map::Map( Float ));

    m = string_map::set (m, "Key1", 0.111);
    m = string_map::set (m, "Key2", 0.222);
    m = string_map::set (m, "Key3", 0.333);

    printf "%s -> %f\n"  "Key1"  (the (string_map::get (m, "Key1")) );
    printf "%s -> %f\n"  "Key2"  (the (string_map::get (m, "Key2")) );
    printf "%s -> %f\n"  "Key3"  (the (string_map::get (m, "Key3")) );
\end{verbatim}

Execution of this script version will not surprise you either:

\begin{verbatim}
    linux$ ./my-script
    Key1 -> 0.111000
    Key2 -> 0.222000
    Key3 -> 0.333000
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees: Int Keys}
\cutdef*{paragraph}

If we want to use {\tt Int} rather than {\tt String} keys we need to 
switch to a different tree variant, but things otherwise work just 
the same.  Here we use the {\tt int\_red\_black\_map} tree variant. 
Since that is a long name, we define the short synonym {\tt map} 
for it within the script:

\begin{verbatim}
    #!/usr/bin/mythryl

    package map = int_red_black_map;

    m = (map::empty: map::Map( String ));

    m = map::set (m, 111, "Value1");
    m = map::set (m, 222, "Value2");
    m = map::set (m, 333, "Value3");

    printf "%d -> %s\n"  111  (the (map::get (m, 111)) );
    printf "%d -> %s\n"  222  (the (map::get (m, 222)) );
    printf "%d -> %s\n"  333  (the (map::get (m, 333)) );
\end{verbatim}

Here is the execution:

\begin{verbatim}
    linux$ ./my-script
    111 -> Value1
    222 -> Value2
    333 -> Value3
\end{verbatim}

Same script rewritten to use {\tt Int} values:

\begin{verbatim}
    #!/usr/bin/mythryl

    package map = int_red_black_map;

    m = (map::empty: map::Map( Int ));

    m = map::set (m, 111, 1111);
    m = map::set (m, 222, 2222);
    m = map::set (m, 333, 3333);

    printf "%d -> %d\n"  111  (the (map::get (m, 111)) );
    printf "%d -> %d\n"  222  (the (map::get (m, 222)) );
    printf "%d -> %d\n"  333  (the (map::get (m, 333)) );
\end{verbatim}

The run:

\begin{verbatim}
    linux$ ./my-script
    111 -> 1111
    222 -> 2222
    333 -> 3333
\end{verbatim}

And now with float values:

\begin{verbatim}
    #!/usr/bin/mythryl

    package map = int_red_black_map;

    m = (map::empty: map::Map( Float ));

    m = map::set (m, 111, 0.111);
    m = map::set (m, 222, 0.222);
    m = map::set (m, 333, 0.333);

    printf "%d -> %f\n"  111  (the (map::get (m, 111)) );
    printf "%d -> %f\n"  222  (the (map::get (m, 222)) );
    printf "%d -> %f\n"  333  (the (map::get (m, 333)) );
\end{verbatim}

The run:

\begin{verbatim}
    linux$ ./my-script
    111 -> 0.111000
    222 -> 0.222000
    333 -> 0.333000
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees: Float Keys; Using the red\_black\_map\_g Generic}
\cutdef*{paragraph}

Mythryl provides pre-built Red-Black tree variants for only 
the most common key types.  {\tt Float} is not so honored, so 
to demonstrate {\tt Float} key values we will need to generate 
our own tree variant from the underlying generic.  This might 
sound a bit scary but is in fact ultra easy --- all we have to 
do is provide the key type and key comparison operation and 
the {\tt red\_black\_map\_g} generic package does all the rest.

\begin{quotation}
{\bf Warning!} In general using {\tt Float} values as keys is 
asking for trouble, because even one part in a billion accumulated 
floating point error on the value used as a key will be enough to make the 
lookup fail!  In a practical situation you should probably round 
your Floats to Ints and use an Int-keyed tree.
\end{quotation}

\begin{verbatim}
    #!/usr/bin/mythryl

    package map
        =
        red_black_map_g (

            Key     =  Float;           # Type to use for keys.
            compare =  float::compare;  # How to compare two keys.
        );

    m = (map::empty: map::Map( String ));

    m = map::set (m, 0.111, "Value1");
    m = map::set (m, 0.222, "Value2");
    m = map::set (m, 0.333, "Value3");

    printf "%f -> %s\n"  0.111  (the (map::get (m, 0.111)) );
    printf "%f -> %s\n"  0.222  (the (map::get (m, 0.222)) );
    printf "%f -> %s\n"  0.333  (the (map::get (m, 0.333)) );
\end{verbatim}

The run:

\begin{verbatim}
    linux$ ./my-script
    0.111000 -> Value1
    0.222000 -> Value2
    0.333000 -> Value3
\end{verbatim}

Same script with {\tt Int} values:

\begin{verbatim}
    #!/usr/bin/mythryl

    package map
        =
        red_black_map_g (

            Key     =  Float;           # Type to use for keys.
            compare =  float::compare;  # How to compare two keys.
        );

    m = (map::empty: map::Map( Int ));

    m = map::set (m, 0.111, 111);
    m = map::set (m, 0.222, 222);
    m = map::set (m, 0.333, 333);

    printf "%f -> %d\n"  0.111  (the (map::get (m, 0.111)) );
    printf "%f -> %d\n"  0.222  (the (map::get (m, 0.222)) );
    printf "%f -> %d\n"  0.333  (the (map::get (m, 0.333)) );
\end{verbatim}

The run:

\begin{verbatim}
    linux$ ./my-script
    0.111000 -> 111
    0.222000 -> 222
    0.333000 -> 333
\end{verbatim}

And finally with {\tt Float} values:

\begin{verbatim}
    #!/usr/bin/mythryl

    package map
        =
        red_black_map_g (

            Key     =  Float;           # Type to use for keys.
            compare =  float::compare;  # How to compare two keys.
        );

    m = (map::empty: map::Map( Float ));

    m = map::set (m, 0.111, 0.1111);
    m = map::set (m, 0.222, 0.2222);
    m = map::set (m, 0.333, 0.3333);

    printf "%f -> %f\n"  0.111  (the (map::get (m, 0.111)) );
    printf "%f -> %f\n"  0.222  (the (map::get (m, 0.222)) );
    printf "%f -> %f\n"  0.333  (the (map::get (m, 0.333)) );
\end{verbatim}


The run:

\begin{verbatim}
    linux$ ./my-script
    0.111000 -> 0.111100
    0.222000 -> 0.222200
    0.333000 -> 0.333300
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees:  The Map API}
\cutdef*{paragraph}

So much for basic functionality.  Now let us look at some of the 
other operations supported by Mythryl Red-Black trees.

At this point you might want to take a quick peek at the  
\ahrefloc{src/lib/src/map.api}{src/lib/src/map.api} file defining 
the Mythryl Red-Black {\sc API}, just to get a sense of the number 
of operations defined.

The richness of the {\tt Map} {\sc API} is not because 
Red-Black trees are complex (in fact they 
are quite simple) but rather because they are heavily used in Mythryl 
software, and consequently people keep asking for just one more 
feature to make them even more useful.

\cutend*

\subsubsection{Red-Black Trees: Construction Shortcuts}
\cutdef*{paragraph}

First, let us look at conveniences which let us streamline our 
code a bit.  Instead of just assigning a short synonym to 
{\tt string\_map} we can {\tt include} it, dumping all of its 
exported symbols directly into our local namespace.  Doing 
this with very many packages will make your local namespace 
a hopeless mess, but it makes sense to do now and then when 
you are using a particular package quite heavily.

Also, 
instead of using the {\tt set} function we can use the 
shorter binary-operator synonym {\tt \$} for it:

\begin{verbatim}
    #!/usr/bin/mythryl

    include package   string_map;

    m = (empty: Map( String ));

    m = m $ ("Key1", "Value1");
    m = m $ ("Key2", "Value2");
    m = m $ ("Key3", "Value3");

    printf "%s -> %s\n"  "Key1"  (the (get (m, "Key1")) );
    printf "%s -> %s\n"  "Key2"  (the (get (m, "Key2")) );
    printf "%s -> %s\n"  "Key3"  (the (get (m, "Key3")) );
\end{verbatim}
 
The run is unchanged:

\begin{verbatim}
    linux$ ./my-script
    Key1 -> Value1
    Key2 -> Value2
    Key3 -> Value3
\end{verbatim}

Like C, Mythryl lets us abbreviate constructs like
\begin{verbatim}
    foo = foo $ bar;
\end{verbatim}
as simply
\begin{verbatim}
    foo $= bar;
\end{verbatim}

We can make our above script even a bit more compact by using 
this contraction.  This is satisfyingly 
concise when used in code doing a lot of data accumulation 
in trees:

\begin{verbatim}
    #!/usr/bin/mythryl

    include package   string_map;

    m = (empty: Map( String ));

    m $= ("Key1", "Value1");
    m $= ("Key2", "Value2");
    m $= ("Key3", "Value3");

    printf "%s -> %s\n"  "Key1"  (the (get (m, "Key1")) );
    printf "%s -> %s\n"  "Key2"  (the (get (m, "Key2")) );
    printf "%s -> %s\n"  "Key3"  (the (get (m, "Key3")) );
\end{verbatim}

The run is again unchanged:

\begin{verbatim}
    linux$ ./my-script
    Key1 -> Value1
    Key2 -> Value2
    Key3 -> Value3
\end{verbatim}


\cutend*

\subsubsection{Red-Black Trees: Testing on Empty}
\cutdef*{paragraph}

Now, what questions might we want to ask of a mapping?

We might want to know whether it was empty or not:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m = empty: Map( String );

    eval:  is_empty m;

    TRUE

    eval:  m $= ("Key1", "Value1");

    eval:  is_empty m;

    FALSE
\end{verbatim}


\cutend*

\subsubsection{Red-Black Trees:  Listing Keys, Values and Key-Value Pairs}
\cutdef*{paragraph}

We might want to know what keys, values, or key-value pairs it contained: 

\begin{verbatim}
    linux$ my
    eval:  include package   string_map;
    eval:  m = empty: Map( String );
    eval:  m $= ("Key1", "Value1");
    eval:  m $= ("Key2", "Value2");
    eval:  m $= ("Key3", "Value3");

    eval:  keys_list m;

    ["Key1", "Key2", "Key3"]

    eval:  vals_list m;

    ["Value1", "Value2", "Value3"]

    eval:  keyvals_list m;

    [("Key1", "Value1"), ("Key2", "Value2"), ("Key3", "Value3")]
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees:  Dropping Key-Value Pairs}
\cutdef*{paragraph}

We might want to drop one key-value pair from it:

\begin{verbatim}
    linux$ my
    eval:  include package   string_map;
    eval:  m = empty: Map( String );
    eval:  m $= ("Key1", "Value1");
    eval:  m $= ("Key2", "Value2");
    eval:  m $= ("Key3", "Value3");

    eval:  keyvals_list m;

    [("Key1", "Value1"), ("Key2", "Value2"), ("Key3", "Value3")]

    eval:  my (m,_) = drop (m, "Key2");

    eval:  keyvals_list m;

    [("Key1", "Value1"), ("Key3", "Value3")]
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees:  Purity Test}
\cutdef*{paragraph}

Here is a little demonstration that these really are pure-functional 
trees which leave pre-existing copies of the tree unchanged after 
an operation:

\begin{verbatim}
    linux$ my
    eval:  include package   string_map;
    eval:  m0 = empty: Map( String );
    eval:  m1 = m0 $ ("Key1", "Value1");
    eval:  m2 = m1 $ ("Key2", "Value2");
    eval:  m3 = m2 $ ("Key3", "Value3");
    eval:  my (m4,_) = drop (m3, "Key2");

    eval:  keyvals_list m0;

    []

    eval:  keyvals_list m1;

    [("Key1", "Value1")]

    eval:  keyvals_list m2;

    [("Key1", "Value1"), ("Key2", "Value2")]

    eval:  keyvals_list m3;

    [("Key1", "Value1"), ("Key2", "Value2"), ("Key3", "Value3")]

    eval:  keyvals_list m4;

    [("Key1", "Value1"), ("Key3", "Value3")]
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees:  Finding First Key or Value}
\cutdef*{paragraph}

We might want to get the first key or key-value pair from a tree, 
perhaps to use it as a poor man's priority queue:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m = empty: Map( String );

    eval:  m $= ("Key1", "Value1");
    eval:  m $= ("Key2", "Value2");
    eval:  m $= ("Key3", "Value3");

    eval:  first_keyval_else_null m;
    THE ("Key1", "Value1")

    eval:  my (m,_) = drop(m, "Key1");

    eval:  first_keyval_else_null m;
    THE ("Key2", "Value2")

    eval:  my (m,_) = drop(m, "Key2");

    eval:  first_keyval_else_null m;
    THE ("Key3", "Value3")

    eval:  my (m,_) = drop(m, "Key3");

    eval:  first_keyval_else_null m;
    NULL
\end{verbatim}


\cutend*

\subsubsection{Red-Black Trees:  Apply}
\cutdef*{paragraph}

We might want to apply some function to all the values in the map:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m = empty: Map( String );

    eval:  m $= ("Key1", "Value1");
    eval:  m $= ("Key2", "Value2");
    eval:  m $= ("Key3", "Value3");

    eval:  apply (printf "<<%s>>\n") m;
    <<Value1>>
    <<Value2>>
    <<Value3>>

    ()
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees:  Map}
\cutdef*{paragraph}

We might want to transform all the values in a map:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m = empty: Map( Int );

    eval:  m $= ("Key1", 1);
    eval:  m $= ("Key2", 2);
    eval:  m $= ("Key3", 3);

    eval:  m = map (sprintf "<<%d>>") m;

    eval:  keyvals_list m;
    [("Key1", "<<1>>"), ("Key2", "<<2>>"), ("Key3", "<<3>>")]
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees:  Filter}
\cutdef*{paragraph}

We might want to drop all key-value pairs 
failing some boolean test on the value:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m = empty: Map( Int );

    eval:  m $= ("Key1", 1);
    eval:  m $= ("Key2", 2);
    eval:  m $= ("Key3", 3);

    eval:  m = filter  (\\ i = (i != 2))  m;

    eval:  keyvals_list m;
    [("Key1", 1), ("Key3", 3)]
\end{verbatim}

We might want to fetch the value of a key 
which might not be present:


\cutend*

\subsubsection{Red-Black Trees:  Get}
\cutdef*{paragraph}

\begin{verbatim}
    #!/usr/bin/mythryl

    include package   string_map;

    m = (empty: Map( String ));

    m $= ("Key1", "Value1");
    m $= ("Key2", "Value2");
    m $= ("Key3", "Value3");

    case (get (m, "Key2"))
        THE value => printf "Key2 -> %s\n" value;
        NULL      => printf "Key2 not in tree\n";
    esac;

    case (get (m, "Key4"))
        THE value => printf "Key4 -> %s\n" value;
        NULL      => printf "Key4 not in tree\n";
    esac;
\end{verbatim}

The run:

\begin{verbatim}
    linux$ ./my-script
    Key2 -> Value2
    Key4 not in tree
\end{verbatim}


\cutend*

\subsubsection{Red-Black Trees:  Folding}
\cutdef*{paragraph}

We might want to combine all the values in ascending or descending order. 
Here the {\tt ""} arguments to {\tt fold\_left} and {\tt fold\_right} are 
the initial values for the {\tt result} accumulators:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m = (empty: Map( String ));

    eval:  m $= ("Key1", "Value1");
    eval:  m $= ("Key2", "Value2");
    eval:  m $= ("Key3", "Value3");

    eval:  fold_forward  (\\ (value,result) = sprintf "%s,%s" value result) "" m;
    "Value3,Value2,Value1,"

    eval:  fold_backward  (\\ (value,result) = sprintf "%s,%s" value result) "" m;
    "Value1,Value2,Value3,"
\end{verbatim}

Or the same as the above but with the keys added into the mix:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m = (empty: Map( String ));

    eval:  m $= ("Key1", "Value1");
    eval:  m $= ("Key2", "Value2");
    eval:  m $= ("Key3", "Value3");

    eval:  keyed_fold_forward  (\\ (key,value,result) = sprintf "(%s,%s),%s" key value result) "" m;
    "(Key3,Value3),(Key2,Value2),(Key1,Value1),"

    eval:  keyed_fold_backward (\\ (key,value,result) = sprintf "(%s,%s),%s" key value result) "" m;
    "(Key1,Value1),(Key2,Value2),(Key3,Value3),"
\end{verbatim}


\cutend*

\subsubsection{Red-Black Trees:  Union and Intersection}
\cutdef*{paragraph}

We might want to take the union or intersection of two maps, 
with an adjudication function to decide which value to use 
when the same key is present in both maps:

\begin{verbatim}
    linux$ my

    eval:  include package   string_map;

    eval:  m1 = (empty: Map( String ));

    eval:  m1 $= ("Key1", "Value1");
    eval:  m1 $= ("Key2", "Value2");
    eval:  m1 $= ("Key3", "Value3");

    eval:  m2 = (empty: Map( String ));

    eval:  m2 $= ("Key0", "Value0");
    eval:  m2 $= ("Key2", "value2");
    eval:  m2 $= ("Key4", "Value4");

    eval:  m3 = union_with  (\\ (value1, value2) = value1 + value2) (m1, m2);

    eval:  keyvals_list m3;

    [("Key0", "Value0"),
     ("Key1", "Value1"), 
     ("Key2", "Value2value2"),
     ("Key3", "Value3"), 
     ("Key4", "Value4")]

    eval:  m4 = intersect_with  (\\ (value1, value2) = value1 + value2) (m1, m2);

    eval:  keyvals_list m4;

    [("Key2", "Value2value2")]
\end{verbatim}


\cutend*

\subsubsection{Red-Black Trees:  File Stat Example}
\cutdef*{paragraph}

There are a few more functions in the {\tt Map} API, but the above 
should be more than enough to get you started.

To close out this section, here is a more realistic example:  We 
will get a list of all the files in the current directory, then 
run {\tt stat} on each to get information such as its size, enter 
the stat results into a map keyed by the filename, and finally 
extract a useful result from the resulting map:

\begin{verbatim}
    #!/usr/bin/mythryl

    package map = string_map;

    stat_map = REF (map::empty: map::Map( posix::stat::Stat ));

    foreach (dir::files ".")
            (\\ filename
                =
                stat_map := map::set (*stat_map, filename, stat filename)
            );

    my (file1, _) =  the (map::first_keyval_else_null *stat_map);

    printf
        "First file is named '%s' and has size %d.\n"
        file1
        (the (map::get (*stat_map, file1))).size;
\end{verbatim}

When run this should produce a result something like
\begin{verbatim}
    linux$ ./my-script
    First file is named '/pub/home/cynbe/mythryl7.110.58/Configure' and has size 328.
\end{verbatim}

The experienced Mythryl programmer tends to dislike avoidable use 
of side-effects, hence might write the above script as:

\begin{verbatim}
    #!/usr/bin/mythryl

    package map = string_map;

    filenames = dir::files ".";

    file1 = head filenames;

    stat_map
        =
        fold_backward
            (\\ (filename, stat_map) = map::set (stat_map, filename, stat filename))
            (map::empty: map::Map( posix::stat::Stat ))
            filenames;

    printf
        "First file is named '%s' and has size %d.\n"
        file1
        (the (map::get (stat_map, file1))).size;
\end{verbatim}

The difference is mostly a matter of taste. 
The result when run will be identical either way:

\begin{verbatim}
    linux$ ./my-script
    First file is named '/pub/home/cynbe/mythryl7.110.58/Configure' and has size 328.
\end{verbatim}

\cutend*

\subsubsection{Red-Black Trees:  Sets and the Set Api}
\cutdef*{paragraph}

The Mythryl Red-Black tree implementations come in two broad sets of variants:
\begin{itemize}
\item Mappings, conforming to \ahrefloc{src/lib/src/map.api}{src/lib/src/map.api}
\item Sets, conforming to \ahrefloc{src/lib/src/set.api}{src/lib/src/set.api}
\end{itemize}

The sets are essentially the map implementations, only storing keys but no values. 
They provide a strict subset of the capabilities of the map variants.  Consequently 
we will forbear covering the Set variants in the detail with which we covered the 
Map variants.

One minor difference is that since the {\tt get} function no longer makes sense in 
the absence of per-key values, we replace it with a {\tt member} function for testing 
key membership in a set:

\begin{verbatim}
    linux$ my

    eval:  package set = string_set;

    eval:  s = set::empty;

    eval:  s = set::add( s, "Key1" );
    eval:  s = set::add( s, "Key2" );
    eval:  s = set::add( s, "Key3" );

    eval:  set::member( s, "Key2" );

    TRUE

    eval:  set::member( s, "Key4" );

    FALSE
\end{verbatim}


\cutend*


\cutend*

% --------------------------------------------------------------------------------
\subsection{Binary Operators}
\cutdef*{subsubsection}
\label{section:tut:delving-deeper:binary-operators}

Some languages treat alphanumeric function names like {\tt sin} as a 
totally separate category from infix operators like {\tt +}.  C, 
for example, will not let you define infix operators at all.

Mythryl regards the distinction between alpanumeric prefix function names and non-alpha 
infix function names as being a largely irrelevant matter of surface syntax.  The 
Mythryl compiler resolves infix operators into exactly the same syntax tree form as 
prefix function names very early in processing and completely disregards the distinction 
thereafter.

Mythryl function names are prefix until specifically declared infix.  Standard 
arithmetic operators like {\tt +} are predefined as infix in the Mythryl standard 
library.  If you wish to use any other function name as infix, you must declare it 
yourself.

Most of the default infix declarations may be found in 
\ahrefloc{src/lib/core/init/pervasive.pkg}{src/lib/core/init/pervasive.pkg}:
\begin{verbatim}
    infix  my 90  ** ;
    infix  my 80  * / % div & // ;
    infix  my 70  $ + - ~ | ^ ? \ ;
    infixr my 60  @ . ! << >> >>> in ;
    infix  my 50  > < >= <= == != =~ .. ;
    infix  my 40  := o ;
    infix  my 20  ==> ;
    infix  my 10  then ;
\end{verbatim}

The decimal numbers give precedence, larger numbers binding more tightly.

Operators declared infix using the {\tt infix} form are treated as 
left-associative;  those declared using {\tt infixr} as right-associative.

The Mythryl parser makes no inherent distinction between alphabetic and 
non-alphabetic function names, as the above {\tt div} and {\tt then} 
declarations attest.

There are two ways to assign a meaning to a binary operator.

One is to simply to assign it the same meaning as some other function:

\begin{verbatim}
    linux$ my

    eval:  fun divmod (i, j) = ((i / j), (i % j));

    eval:  infix my 80 /% ;

    eval:  /% = divmod;

    eval:  27 /% 6;
    (4, 3)
\end{verbatim}

This is often the most practical approach, since you typically want 
to have a convenient vanilla name for the function anyhow, for 
passing naturally to functions like {\tt map}.

The second way is to just directly define the operator 
using infix syntax.  This is unquestionably the more elegant approach:

\begin{verbatim}
    linux$ my
    eval:  infix my 80  /% ;
    eval:  fun i /% j = ((i / j), (i % j));
    eval:  27 /% 6;
    (4, 3)
\end{verbatim}


\cutend*


% --------------------------------------------------------------------------------
\subsection{Roll-Your-Own Objected Oriented Programming}
\cutdef*{subsubsection}
\label{section:tut:delving-deeper:roll-your-own-oop}

There are about as many definitions of "object oriented programming" as there 
are object oriented languages, but implementation hiding and dynamic (runtime) 
binding of methods are central to most of them.  We will discuss more elaborate 
approachs to object oriented programming in Mythryl 
\ahrefloc{section:tut:full-monte:experimental-object-oriented-programming-support}{later}, 
later, but here is a very simple technique which is often enough for the job at hand. 

The idea is to create some state which is shared by a set of functions but 
hidden from the rest of the program, and then to access those functions via 
a record of pointers to them.

For didactic clarity we will take as our example a simple counter which may 
be incremented, read or reset:

\begin{verbatim}
    #!/usr/bin/mythryl

    fun make_counter ()
        =
        {
            # Create counter state, initialized to zero:
            #
            count = REF 0;

            # Define our methods
            #
            fun increment () =  count := *count + 1;
            fun get       () = *count;
            fun reset     () =  count := 0;

            # Create and return record of methods:
            #
            { increment, get, reset };
        };


    # Demonstration of counter use:
    print "\n";

    counter = make_counter ();      printf "State of counter after creation  d=%d\n" (counter.get ());
    counter.increment ();           printf "State of counter after increment d=%d\n" (counter.get ());
    counter.reset ();               printf "State of counter after reset     d=%d\n" (counter.get ());
\end{verbatim}

When run this script will print out:

\begin{verbatim}
    linux$ ./my-script

    State of counter after creation  d=0
    State of counter after increment d=1
    State of counter after reset     d=0
\end{verbatim}

Things to note about this technique:

\begin{itemize}
\item The only access to object state is via the exported methods.
\item You may make as many counter objects as you please.
\item The type of the counter depends only on the types and names of its methods, 
      not on the internal implementation details.  Consequently different kinds 
      of counters may be used interchangably in external code so long as they 
      support the same interface, which is to say, so long as their methods have 
      the same names and same types.
\end{itemize}

For an industrial strength example of this technique in action see the library 
graph implementation in  
\ahrefloc{src/lib/graph/oop-digraph.api}{src/lib/graph/oop-digraph.api} and 
\ahrefloc{src/lib/graph/oop-digraph.pkg}{src/lib/graph/oop-digraph.pkg}.

\cutend*


% --------------------------------------------------------------------------------
\subsection{Prefix, Postfix and Circumfix Operators}
\cutdef*{subsubsection}

The Mythryl lexer distinguishes between certain infix and prefix arithmetic 
operators by the presence or absence of adjacent whitespace:

\begin{verbatim}
    a-b;               # binary infix
    a - b;             # binary infix
    a -b;              # unary prefix
    a- b;              # unary postfix
\end{verbatim}

This is something of a kludge, but it allows us to use ascii 
{\it -} for both subtraction and negation and ascii {\tt *} for 
both multiplication and dereferencing, making the most of the 
very limited number of available seven-bit ascii characters.

Thus, in Mythryl one can define factorial quite naturally as

\begin{verbatim}
    #!/usr/bin/mythryl

    fun 0! =>  1;
        n! =>  n * (n - 1)! ;
    end;

    printf "%d\n" 3! ;
\end{verbatim}

Running this yields:

\begin{verbatim}
    linux$ ./my-script
    6
    linux$
\end{verbatim}

Judiciously used, this capability can significantly improve code readability.

Mythryl also supports a limited number of circumfix operators, including

\begin{verbatim}
    |x|
    <x>
    /x/
    {i}
\end{verbatim}

This allows for example a more natural absolute value (or magnitude) 
function definitions:

\begin{verbatim}
    #!/usr/bin/mythryl

    fun |x| =  (x < 0) ?? -x :: x;

    a = -3;

    printf "%d\n" |a| ;
\end{verbatim}

Running this yields:

\begin{verbatim}
    linux$ ./my-script
    3
    linux$
\end{verbatim}


Special for fans of quantum mechanics, Mythryl even allows you to define 

\begin{verbatim}
    <x|
    |x>
\end{verbatim}

For example:

\begin{verbatim}
    #!/usr/bin/mythryl

    fun <x| =  printf "Wait a minute! You don't look like a quantum mechanic!\n";

    psi = 42;

    <psi| ;
\end{verbatim}

The script output when run should be no surprise:

\begin{verbatim}
    linux$ ./my-script
    Wait a minute! You don't look like a quantum mechanic!
    linux$
\end{verbatim}


\cutend*

% --------------------------------------------------------------------------------
\subsection{Multi-file Projects: Libraries and API Definitions}
\cutdef*{subsubsection}
\label{section:tut:delving-deeper:libraries-and-apis}


One-file scripts are great for little system administration tasks 
and the like, but eventually you will want to write a serious 
application in Mythryl, and at that point you need to be able to 
divide the source code up logically between multiple files with 
cleanly defined interfaces between them.  It is time we examined 
how to do that in Mythryl.

First we need to talk a little bit about API definition.  Critical 
to the construction of any large software project is the concept 
of {\it implementation hiding}, of dividing the code up into modules 
which each expose to the external world only a simple, clean, 
well-defined interface.  Code within each module can then be 
freely modified as long as the interface remains unchanged. 
This makes maintenance and evolution of large software systems 
enormously easier.

In Mythryl we define such module interfaces using the {\tt api} 
construct.

Suppose for example that we want to create a library of functions to do useful 
things with Mythryl lists.  We will call the library {\tt list\_lib} 
and in it we will define a function {\tt list\_length} which accepts 
a list of strings and returns the length of that list as an integer. 
This library will have various internal functions, but the only 
function it will export to the external world will be {\tt list\_length}.

We will implement this by writing an API which we will call 
{\tt List\_Lib}, which will define the external interface to our 
library:

\begin{verbatim}
    api List_Lib {
        list_length:  List(String) -> Int;
    };
\end{verbatim}

This says that the {\tt List\_Lib} api makes available to the external 
world a single function named {\tt list\_length} which accepts a 
list of strings and returns an integer.

Now we implement our library package proper:

\begin{verbatim}
    package list_lib: List_Lib {

        # Private helper function for computing
        # list length.  Its second argument
        # counts the number of list elements
        # seen so far.  This is a common MythryL idiom:
        #
        fun length_helper (rest_of_list, nodes_seen)
            =
            if (rest_of_list == [])    nodes_seen;                                              # Done, return count. 
            else                       length_helper( tail(rest_of_list), nodes_seen + 1 );     # Count rest of list recursively.
            fi;

        fun list_length a_list
            =
            length_helper (a_list, 0);
    };
\end{verbatim}

The {\tt package list\_lib: List\_Lib} looks like a package {\sc API} declaration, 
but in fact it is a {\it package cast} which forces the external view of the 
{\tt list\_lib} package to be exactly that specified by the {\tt List\_Lib} {\sc API} definition.

Here the {\tt length\_helper} helper function does all the real work, but 
it is not externally visible because we did not list it in our {\tt List\_Lib} 
api definition.  This is a simple example of implementation hiding.

The {\tt list\_length} function is really just a wrapper around {\tt length\_helper}, 
but it is the only externally visible part of the package.

We can test our package and api using a little script:

\begin{verbatim}
    #!/usr/bin/mythryl

    api List_Lib {
        list_length:  List(String) -> Int;
    };

    package list_lib: List_Lib {

        # Private helper function for computing
        # list length.  Its second argument
        # counts the number of list elements
        # seen so far.  This is a common MythryL idiom:
        #
        fun length_helper (rest_of_list, nodes_seen)
            =
            if (rest_of_list == [])    nodes_seen;                                              # Done, return count. 
            else                       length_helper( tail(rest_of_list), nodes_seen + 1 );     # Count rest of list recursively.
            fi;

        fun list_length a_list
            =
            length_helper (a_list, 0);
    };

    printf "list length is %d\n"  (list_lib::list_length( ["abc", "def", "ghi"] ));
\end{verbatim}

When run, this yields

\begin{verbatim}
    linux$ ./my-script
    list length is 3
    linux$ 
\end{verbatim}

But declaring an api and package within a script file was not the point; 
the point was to compile multi-file applications.  To do that, save 
the package definition in a file named {\tt list-lib.pkg}, the api 
declaration in a file named {\tt list-lib.api} and create a file 
named {\tt list-lib.lib} to control their compilation with contents 
as shown below, and compile the complete fileset interactively as shown:

\begin{verbatim}
    linux$ cat list-lib.api

    api List_Lib {
        list_length:  List(String) -> Int;
    };

    linux$ cat list-lib.pkg

    package list_lib: List_Lib {

        # Private helper function for computing
        # list length.  Its second argument
        # counts the number of list elements
        # seen so far.  This is a common MythryL idiom:
        #
        fun length_helper (rest_of_list, nodes_seen)
            =
            if (rest_of_list == [])    nodes_seen;                                              # Done, return count. 
            else                       length_helper( tail(rest_of_list), nodes_seen + 1 );     # Count rest of list recursively.
            fi;

        fun list_length a_list
            =
            length_helper (a_list, 0);
    };

    linux$ cat list-lib.lib

    LIBRARY_EXPORTS

            api List_Lib
            pkg list_lib

    LIBRARY_COMPONENTS

            $ROOT/src/lib/std/standard.lib

            list-lib.api
            list-lib.pkg


    linux$ my

    eval:  make "list-lib.lib";
        src/app/makelib/main/makelib-g.pkg:   Running   .lib file    list-lib.lib
          parse/libfile-parser-g.pkg:   Reading   make   file   list-lib.lib                                          on behalf of <toplevel>
    .../compile/compile-in-dependency-order-g.pkg:   Loading                 list-lib.api
    .../compile/compile-in-dependency-order-g.pkg:   Loading                 list-lib.pkg
        src/app/makelib/main/makelib-g.pkg:   New names added.

    TRUE

    eval:  makelib::show_all();

    Top-level definitions:
    [...]
    api List_Lib
    pkg list_lib
    val it

    ()

    eval:  list_lib::list_length( ["abc", "def", "ghi"] );

    3
\end{verbatim}

Here we used {\tt make "list-lib.lib";} to compile and load our library, 
then we used {\tt makelib::show\_all();} to list all loaded packages and apis, 
verifying that {\tt List\_Lib} and {\tt list\_lib} were now present, and then 
invoked our library by evaluating {\tt list\_lib::list\_length( ["abc", "def", "ghi"] );}, 
verifying that it returned the expected value of three.

The {\tt list-lib.lib} file contents should be reasonably self-explanatory.

The {\sc LIBRARY\_COMPONENTS} section lists all source files which should be 
compiled to form the library, together with all the sub-libraries needed by 
those source files.  You will probably always want to list the standard 
Mythryl libraries {\tt \verb|$ROOT/src/lib/std/standard.lib|} in this section; if 
you have additional sub-libraries of your own needed by the source files 
in this library, you will need to list them as well.

The {\sc LIBRARY\_EXPORTS} section lists all of the apis and packages which 
should be made externally visible to users of your package.  Just as a 
package may have internal functions which are not made externally visible, 
so a complex library may have entire packages which are for internal use 
only and not made externally visible.

We shall have more to say about Mythryl libraries 
\ahrefloc{section:tut:full-monte:library-freezing}{later} but right 
now it is time to learn how to compile stand-alone executables.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Multi-file Projects: Compiling a Stand-Alone Executable}
\cutdef*{subsubsection}
\label{section:tut:delving-deeper:compiling-a-stand-alone-executable}

To develop useful multi-file applications, you will also need to know how 
to compile a stand-alone executable which can be invoked from the 
command line or scripts like any other Linux executable.

In this section we will present a complete worked-out example of 
implementing a simple clone of the Linux {\tt factor} program, 
which prints out the prime factorization of each argument it is 
given.

Our solution consists of the following four files:
\begin{itemize}
\item A {\tt factor.api} file defining the api for the core factoring module.
\item A {\tt factor.pkg} file implementing the core factoring module.
\item A {\tt main.pkg} file implementing the Mythryl equivalent of a C {\tt main()} function.
\item A {\tt factor.lib} makefile to drive the compilation process.
\end{itemize}

Using these we will compile a {\tt factor} executable image using 
the standard Mythryl {\tt /usr/bin/build-an-executable-mythryl-heap-image} 
script which gets installed with the other standard Mythryl programs 
when you do a {\tt make install}.

The following transcript shows the contents of the required files and 
also the compilation process:

\begin{verbatim}
    linux$ cat factor.api

    api Factor {
        factors: Int -> List(Int);
    };

    linux$ cat factor.pkg

    package factor {

        fun factor_helper (i, trial_divisor, known_factors) = {

            if (trial_divisor > i)   reverse known_factors;
            else
                if (i % trial_divisor != 0)   factor_helper (i,               trial_divisor + 1,                  known_factors);
                else                          factor_helper (i/trial_divisor, trial_divisor,      trial_divisor ! known_factors);
                fi;
            fi;
        };

        fun factors( i ) = {
            if (i <= 1)  [i];
            else         factor_helper (i, 2, []);
            fi;
        };
    };

    linux$ cat main.pkg

    package main:  api {
                       main: ((String, List( String )))   ->   winix__premicrothread::process::Status;
                   }
    {
        include package   trap_control_c;         # trap_control_c        is from   src/lib/std/trap-control-c.pkg

        fun print_to_stderr msg
            =
            file::write
                (
                  file::stderr,
                  string::cat msg
                );

        fun print_factors( number, factors ) = {
            printf "%d:" number;
            map (printf " %d") factors;
            printf "\n";
        };

        fun factor_number( arg ) = {
            number = the (int::from_string arg);
            print_factors( number, factor::factors( number ) );
        };

        fun factor_args args = {
            apply factor_number args;
        };

        fun main (name, args) = {

            fun run_program ()
                =
                factor_args args;

            {   catch_interrupt_signal  run_program;
                winix__premicrothread::process::success;
            }
            except
                CONTROL_C_SIGNAL
                    =>
                    {   print_to_stderr [name, ": Interrupt\n"];
                        winix__premicrothread::process::failure;
                    };

                any =>
                    {   print_to_stderr [   name,
                                ": uncaught exception ",
                                exceptions::exception_message any,
                                "\n"
                            ];

                        winix__premicrothread::process::failure;
                    };
            end ;
        };
    };

    linux$ cat factor.lib

    LIBRARY_EXPORTS

            api Factor
            pkg factor
            pkg main

    LIBRARY_COMPONENTS

            $ROOT/src/lib/std/standard.lib

            factor.api
            factor.pkg

            main.pkg

    linux$ build-an-executable-mythryl-heap-image factor.lib main::main
     _build-an-executable-mythryl-heap-image:   Starting.
     _build-an-executable-mythryl-heap-image:   main=main::main (III)
     _build-an-executable-mythryl-heap-image:   main=main::main (after sed)
     _build-an-executable-mythryl-heap-image:   Listing tmp-makelib-pid-26077-export.pkg:

    pkg xyzzy_plugh { my _ = lib7::spawn_to_disk ("factor", main::main); };

     _build-an-executable-mythryl-heap-image:   Listing .lib file:

    SUBLIBRARY_EXPORTS pkg xyzzy_plugh SUBLIBRARY_COMPONENTS $ROOT/src/lib/std/standard.lib factor.lib tmp-makelib-pid-26077-export.pkg

     _build-an-executable-mythryl-heap-image:   Doing:                  "/usr/bin/mythryld"  --build-an-executable-mythryl-heap-image  "factor.lib" "tmp-makelib-pid-26077-export.lib" "factor" "tmp-makelib-pid-26077.COMPILED_FILES_TO_LOAD" "tmp-makelib-pid-26077.LINKARGS"
                parse/libfile-parser-g.pkg:   Reading   make   file   factor.lib                                            on behalf of <toplevel>
  app/makelib/compilable/thawedlib-tome.pkg:   Parsing   source file   factor.api
  app/makelib/compilable/thawedlib-tome.pkg:   Parsing   source file   factor.pkg
  app/makelib/compilable/thawedlib-tome.pkg:   Parsing   source file   main.pkg
          .../compile/compile-in-dependency-order-g.pkg:   Compiling source file   factor.api                                              to object file   factor.api.compiled
          .../compile/compile-in-dependency-order-g.pkg:   Compiling source file   factor.pkg                                              to object file   factor.pkg.compiled
          .../compile/compile-in-dependency-order-g.pkg:   Compiling source file   main.pkg                                                to object file   main.pkg.compiled
                parse/libfile-parser-g.pkg:   Reading   make   file   tmp-makelib-pid-26077-export.lib                        on behalf of <toplevel>
                parse/libfile-parser-g.pkg:   Reading   make   file   factor.lib                                            on behalf of <toplevel>
  app/makelib/compilable/thawedlib-tome.pkg:   Parsing   source file   tmp-makelib-pid-26077-export.pkg
          .../compile/compile-in-dependency-order-g.pkg:   Compiling source file   tmp-makelib-pid-26077-export.pkg                          to object file   tmp-makelib-pid-26077-export.pkg.compiled

              src/app/makelib/main/makelib-g.pkg:   Creating file 'tmp-makelib-pid-26077.COMPILED_FILES_TO_LOAD'


              src/app/makelib/main/makelib-g.pkg:   Creating file 'tmp-makelib-pid-26077.LINKARGS'

     _build-an-executable-mythryl-heap-image:   Doing:                        "/usr/bin/mythryl-ld" `cat "tmp-makelib-pid-26077.LINKARGS"`

    ----------------------------------------------------
                              bin/mythryl-ld:   Starting
                              bin/mythryl-ld:   Exec()'ing                              /pub/home/cynbe/src/mythryl/mythryl7/mythryl7.110.58/mythryl7.110.58/bin/mythryl-runtime-intel32 --runtime-compiledfiles-to-load=tmp-makelib-pid-26077.COMPILED_FILES_TO_LOAD --runtime-heap=mythryld 

   src/c/main/load-compiledfiles.c:   Writing load log to               mythryld-26088.load.log

   src/c/main/load-compiledfiles.c:   Reading   file          tmp-makelib-pid-26077.COMPILED_FILES_TO_LOAD

        .../lib/heap/export-fun.c:   Writing   executable (heap image) /pub/home/cynbe/src/mythryl/mythryl7/mythryl7.110.58/mythryl7.110.58/factor

    linux$ ./factor 23 24
    23: 23
    24: 2 2 2 3

    linux$
\end{verbatim}

The above code is largely self-explanatory;  you should have little difficulty 
adapting it to your own needs.

For your convenience, the above code is shipped in the 
{\tt src/app/tut/factor/} directory in the Mythryl source 
code distribution.

For a serious application, you will probably want to put the 
illustrated {\tt build-an-executable-mythryl-heap-image} call 
in your application's Linux Makefile.  (The Mythryl {\tt makelib} 
is not intended to replace Linux {\tt make}, but rather to 
work with it in complementary fashion.  Each does well things 
the other does poorly.)

The {\tt main.pkg} file is mostly boilerplate that you can use 
unchanged in your own application except for changing the 
{\tt run\_program} function to run the code appropriate to your 
application.

A serious application will have many more source files and perhaps 
application-specific {\tt .lib} libraries.  Just add them to the 
{\tt factor.lib} file (presumably appropriately renamed for your 
application) and Mythryl's {\tt makelib} will take care of compiling 
everything in the right order.  (Unlike Linux {\tt make}, Mythryl 
{\tt makelib} deduces needed dependency relationships directly 
from the source code.)

A nontrivial application will probably support various command line 
options.  You may wish to process them using the 
\ahrefloc{pkg:process\_commandline}{process\_commandline} package, 
which is a Mythryl port of the {\sc GNU} {\tt getopt} C package.



\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl Backticks Operators}
\cutdef*{subsubsection}

Bash, Perl and a number of other modern scripting-influenced languages 
supply a backticks operator returning the output from an executed 
shell expression:

\begin{verbatim}
    #!/usr/bin/perl -w
    use strict;
    my $text = `ls -l`;
\end{verbatim}

Mythryl implements a similar backquote operator:

\begin{verbatim}
    linux$ my

    eval:  text = `ls -l`;

    eval:  print text;
    total 5028
    drwxr-xr-x 2 cynbe cynbe    4096 2009-03-12 03:53 bin
    -rwxr-xr-x 1 cynbe cynbe     328 2007-11-26 00:34 Configure
    drwxr-xr-x 4 cynbe cynbe    4096 2009-03-02 23:34 doc
    drwxr-xr-x 2 cynbe cynbe    4096 2008-01-10 14:10 etc
    -rw-r--r-- 1 cynbe cynbe   30127 2009-03-12 03:51 LIBRARY_CONTENTS
    -rw-r--r-- 1 cynbe cynbe    1178 2009-03-12 03:56 main.log~
    -rw-r--r-- 1 cynbe cynbe 3558521 2009-03-12 03:53 MAKELIB_FILE_HIERARCHY.INFO~
    -rw-r--r-- 1 cynbe cynbe   25328 2009-03-08 22:57 Makefile
    -rwxr-xr-x 1 cynbe cynbe     386 2009-03-12 03:22 my-script
    -rw------- 1 cynbe cynbe  601330 2009-03-12 03:56 mythryl.compile.log
    -rw-r--r-- 1 cynbe cynbe  219341 2009-03-12 03:51 mythryld-9748.load.log
    -rw-r--r-- 1 cynbe cynbe  129121 2009-03-12 03:51 COMPILED_FILES_TO_LOAD
    -rw-r--r-- 1 cynbe cynbe  492671 2009-03-12 03:56 read-eval-print-loop.log~
    -rw-r--r-- 1 cynbe cynbe    3338 2009-03-04 17:37 README
    drwxr-xr-x 3 cynbe cynbe    4096 2009-03-09 05:10 sh
    drwxr-xr-x 6 cynbe cynbe    4096 2009-03-08 20:36 src
    -rw-r--r-- 1 cynbe cynbe     353 2007-09-06 21:52 TODO
    drwxr-xr-x 3 cynbe cynbe    4096 2009-02-21 14:05 try
    -rw-r--r-- 1 cynbe cynbe      27 2008-02-07 03:06 w
    -rwxr-xr-x 1 cynbe cynbe     124 2008-03-09 22:05 y
    -rwxr-xr-x 1 cynbe cynbe     501 2008-01-06 13:15 z
\end{verbatim}


A major difference is that early in compilation the Mythryl compiler 
expands this operator into a call to the {\tt back\_\_ticks} function.

This means that just by redefining the {\tt back\_\_ticks} function, the 
application programmer can redefine the meaning of the backticks 
construct.

This can be useful, for example, in a file defining many TCP/IP 
dotted-quad addresses, allowing syntax like

\begin{verbatim}
    open_socket( `192.168.0.1` );
\end{verbatim}

to be substituted for perhaps

\begin{verbatim}
    open_socket( IP_ADDRESS (192, 168, 0, 1) );
\end{verbatim}

If the construct is being used only once or twice, this is not a 
significant win, but if a long file configuring (say) a 
mail transport agent contains hundreds of such constructs, the 
difference in readability may be substantial.

A similar {\tt dot\_\_backticks} operator is also implemented by 
the Mythryl front end, expanding from syntax like

\begin{verbatim}
    open_socket( .`192.168.0.1` );
\end{verbatim}

By defining {\tt dot\_\_backticks}, you can make the construct 
do whatever you want with the quoted string:

\begin{verbatim}
    linux$ my

    eval:  dot__backticks = toupper;

    eval:  .`this is weird`;
    "THIS IS WEIRD"
\end{verbatim}

To implement the above IP address facility we might write something like:

\begin{verbatim}
    #!/usr/bin/mythryl

    Ip_Address = IP_ADDRESS (Int, Int, Int, Int);

    fun dot__backticks  ip_address_string
        =
        case (regex::find_first_match_to_regex_and_return_all_groups
                  ./^(\d+)\.(\d+)\.(\d+)\.(\d+)$/
                  ip_address_string)

        THE [ a, b, c, d ]   => IP_ADDRESS( atoi a, atoi b, atoi c, atoi d );
        _                    => raise exception DIE "Invalid IP address syntax";
        esac;
\end{verbatim}

With these definitions in place we can do:

\begin{verbatim}
    eval:  .`123.194.12.14`;
    IP_ADDRESS (123, 194, 12, 14)

    eval:  .`123.43.23`;
    unCaUght exception DIE [DIE: Invalid IP address syntax]
\end{verbatim}

The Mythryl standard library assigns no default definition to 
the {\tt dot\_\_backticks} function.

In a similar vein, {\tt ."a b c d"} expands early in the Mythryl front 
end into {\tt dot\_\_qquotes "a b c d"}. 
The  \ahrefloc{pkg:scripting\_globals}{scripting\_globals} 
package sets {\tt dot\_\_qquotes} to {\tt words} which in turn is defined as

\begin{quotation}
~~~~~~~~words  = \ahrefloc{pkg:string}{string}::tokens \ahrefloc{pkg:string}{char}::is\_space;
\end{quotation}

Consequently, by default this construct provides a convenient way 
to specify lists of short words.  It is somewhat like the Perl 
{\tt qw/.../} construct:

\begin{verbatim}
    linux> my

    eval:  ."a b c d e f";

    ["a", "b", "c", "d", "e", "f"]
\end{verbatim}

This can substantially improve readability in certain sorts of programming. 

Once again, by redefining {\tt dot\_\_qquotes} the application programmer may repurpose 
this facility for other needs:

\begin{verbatim}
    linux$ my

    eval:  dotqquotes__op = implode o shuffle o explode;

    eval:  ."abcdefgh"
    "hcdefgba"
\end{verbatim}

In similar fashion 
{\tt .'foo'} expands into a call to {\tt dot\_\_quotes}, 
{\tt .<foo>} expands into a call to {\tt dot\_\_brokets}, 
{\tt .|foo|} expands into a call to {\tt dot\_\_barets}, {\tt .#foo#} expands 
into a call to {\tt dot\_\_hashets} and {\tt ./foo/} expands into a call to 
{\tt dot\_\_slashets}.  All of these functions default to the identity function. 
Also, the only escape sequence recognized within any of these quotation constructs 
is doubling of the terminator to include it in the string; for example {\tt .#foo##bar#} 
is equivalent to {\tt "foo#bar}.  This makes them useful for avoiding the need to 
double all backslashes in regular expressions.

\cutend*


% --------------------------------------------------------------------------------
\subsection{Mythryl eval Operators}
\cutdef*{subsubsection}

Scripting languages such as Perl frequently implement an {\tt eval} operator 
allowing execution of source code strings dynamically created by the running 
script.  This has a variety of handy uses ranging from implementing systems 
which interactively execute user-entered code to system which dynamically 
compile special-case code at need.

Mythryl implements a supported {\tt eval} operator for accessing incremental 
compilation functionality:

\begin{verbatim}
    linux> my

    eval:  evali "2 + 2";

    4
\end{verbatim}

Perl and bash, being dynamically typed, are not bothered by the fact 
that the type of {\tt eval} depends entirely upon the contents of its 
string argument.

In a language like Mythryl this ill-typedness is more 
problematic.  This is not an unsurmountable problem.  If it were, 
Mythryl's interactive mode would not be able to print out the 
values of interactively entered expressions.  But the solution 
is not something you would want to examine immediately before a meal.

Eventually, {\tt eval} should be tweaked to have type {\tt String -> X} 
where X can change from invocation to invocation.  (Implementing this 
might be a nice undergrad compiler course project.  Email me a patch 
and I'll merge it in!)

For the moment, at least, Mythryl's solution is just to supply in the 
library a half dozen odd statically typed {\tt eval} variants covering 
common cases:

\begin{verbatim}

    eval:   String -> Void;

    evali:  String -> Int;
    evalf:  String -> Float;
    evals:  String -> String;

    evalli: String -> List( Int    );
    evallf: String -> List( Float  );
    evalls: String -> List( String );

\end{verbatim}

Additional variants may be implemented as needed by 
cloning and tweaking the existing routines.

This isn't a great solution, but it is much better than nothing!

\cutend*

% --------------------------------------------------------------------------------
\subsection{Summary}
\cutdef*{subsubsection}

\begin{quote}\begin{tiny}
        ``A Real Programmer can write Fortran in any language.''\newline
\newline
\end{tiny}\end{quote}

Congratulations!  

You now know enough to be able to write recognizably idiomatic Mythryl in Mythryl, 
and to write useful applications.

If, after the first sequence of tutorials, we were like music students 
who knew how to keep warm by burning Stradivarius violins, we are now 
like music students who know how to make music with a Stradivarius 
violin --- by beating time on it with a stick.

In the next sequence of tutorials, we shall investigate the world of 
possibilities opened up by playing {\it notes} on that violin.

But first, this is an excellent time at which to pause for a little 
learning by doing, consolidating what you have learned so far and 
building some of the cool programming projects that have been brewing 
in the back of your mind.

\cutend*
