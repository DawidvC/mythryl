# gtk-client-driver-for-library-in-main-process.pkg
#
# This file handles the Mythryl side
# of the Mythryl <-> C interface
# layer for the Mythryl Gtk-in-main-process
# Gtk binding.  The C side is implemented by
#
#     src/c/lib/gtk/mythryl-gtk-library-in-main-process.c
#
# Here we implement only low-level pipe-specific functionality.
# In src/opt/gtk/src/gtk-client-for-library-in-main-process.pkg we are passed as an argument
# to the generic handling the higher-level stuff:
#
#     gtk_client_g from   src/opt/gtk/src/gtk-client-g.pkg
#
# Our alternative Gtk-in-subprocess implementation is in
#
#     src/opt/gtk/src/gtk-client-driver-for-library-in-c-subprocess.pkg

# Compiled by:
#     src/lib/std/standard.lib


# Immediate TODO list:
#   o Hack gtk-client-driver-for-library-in-main-process.pkg so all binding fns theoretically work.
#   o Figure out what happens when GTK_ADJUSTMENT() and such throw an error and how to trap and handle it.
#   o Hack make-gtk-glue to process pending callbacks at end of each binding fn.
#   o Hack both drivers to use decomposed outer loop.
#         http://www.gtk.org/api/2.6/glib/glib-The-Main-Event-Loop.html
#   o Hack gtk-via-driver-unit-test.pkg to use decomposed loop and actually press its button.

stipulate
    package imp =  int_red_black_map;						# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg
herein

    package gtk_client_driver_for_library_in_main_process: Gtk_Client_Driver {	# Gtk_Client_Driver			is from   src/opt/gtk/src/gtk-client-driver.api
	#
	package ci = unsafe::mythryl_callable_c_library_interface;		# unsafe				is from   src/lib/std/src/unsafe/unsafe.pkg
										# mythryl_callable_c_library_interface	is from   src/lib/std/src/unsafe/mythryl-callable-c-library-interface.pkg
	include package   gtk_event;						# gtk_event				is from   src/opt/gtk/src/gtk-event.pkg


	Session = { callback_map:     { void:              Ref (imp::Map( Void            -> Void )),
					bool:              Ref (imp::Map( Bool            -> Void )),
					float:             Ref (imp::Map( Float           -> Void )),
					button_event:      Ref (imp::Map( Button_Event    -> Void )),
					motion_event:      Ref (imp::Map( Motion_Event    -> Void )),
					key_event:         Ref (imp::Map( Key_Event       -> Void )),
					expose_event:      Ref (imp::Map( Expose_Event    -> Void )),
					configure_event:   Ref (imp::Map( Configure_Event -> Void ))
				      }
				      # callback_maps is created by our client  src/opt/gtk/src/gtk-client-g.pkg
				      # and passed to us via our make_session call.  We read it but never write it.
		  };



	# Define the different types of
	# callback queue entries supported.
	#
	# WARNING! Must be kept in sync
	# with matching declarations in
	#
	#     src/c/lib/gtk/mythryl-gtk-library-in-main-process.c
	#
	my          queued_void_callback = 1;
	my          queued_bool_callback = 2;
	my         queued_float_callback = 3;
	my  queued_button_press_callback = 4;
	my     queued_key_press_callback = 5;
	my queued_motion_notify_callback = 6;
	my        queued_expose_callback = 7;
	my     queued_configure_callback = 8;

	my init:   Void -> Void
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "init" };

	#################################################################################################
	# These functions are our interface to the
	#     callback_queue[]
	# in
	#     src/c/lib/gtk/mythryl-gtk-library-in-main-process.c
	# 
	my  callback_queue_is_empty:   Void -> Bool
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "callback_queue_is_empty" };

	# 
	my  number_of_queued_callbacks:   Void -> Int
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "number_of_queued_callbacks" };

	# 
	my  type_of_next_queued_callback:   Void -> Int
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "type_of_next_queued_callback" };

	# 
	my  get_queued_void_callback:   Void -> Int
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_void_callback" };

	# 
	my  get_queued_bool_callback:   Void -> (Int, Bool)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_bool_callback" };

	# 
	my  get_queued_float_callback:   Void -> (Int, Float)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_float_callback" };

	# 
	my  get_queued_button_press_callback:   Void -> (Int, Int, Int, Float, Float, Int, Int)	# Void -> (callback_number, widget_id, button, x, y, time, modifiers)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_button_press_callback" };

	# 
	my  get_queued_key_press_callback:   Void -> (Int, Int, Int, Int, Int)			# Void -> (callback_number, key, keycode, time, modifiers)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_key_press_callback" };

	# 
	my  get_queued_motion_notify_callback:   Void -> (Int, Int, Int, Float, Float, Int, Bool)	# Void -> (callback_number, widget_id, time, x, y, modifiers, is_hint)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_motion_notify_callback" };

	# 
	my  get_queued_expose_callback:   Void -> (Int, Int, Int, Int, Int, Int, Int)		# Void -> (callback_number, widget, count, area_x, area_y, area_wide, area_high)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_expose_callback" };

	# 
	my  get_queued_configure_callback:   Void -> (Int, Int, Int, Int, Int, Int)			# Void -> (callback_number, widget, x,    y,    wide, high)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_configure_callback" };



	#################################################################################################
	# These functions are too irregular to fit into our
	# usual code autogeneration scheme:

	# 
	my do_get_widget_allocation:  Int -> (Int, Int, Int, Int)					# Widget -> (x, y, wide, high)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_widget_allocation" };

	# 
	my do_get_window_pointer:  Int -> (Int, Int, Int)						# Widget -> (x, y, modifiers)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_window_pointer" };

	# 
	my do_make_dialog:  Void -> (Int, Int, Int)							# Void -> (dialog, vbox, action_area)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "make_dialog" };

	# 
	my do_unref_object:  Int -> Void								# Widget -> Void
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "unref_object" };

	# 
	my do_run_eventloop_once:  Bool -> Bool							# Bool -> Bool
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "run_eventloop_once" };


	# A line like
	#     "CALLBACK17"
	# means to execute callback 17
	# in our callback_map.
	#
	# A line like
	#     "BOOL_CALLBACK17 TRUE"
	# means to execute callback 17
	# in our callback_map.bool with an argument of TRUE.
	#
	# A line like
	#     "FLOAT_CALLBACK17 2.3"
	# means to execute callback 17
	# in our callback_map.float with an argument of 2.3.
	#
	# A line like
	#     "BUTTON_CALLBACK17 1 23.3 52.9"
	# means to tell callback 17 that mouse button 1 was clicked at x,y of (23.3, 52.9)
	# ...
	# and so forth. :)
	#
	fun run_pending_callbacks  (session: Session): Void
	    =
	    # Check how many callbacks are currently
	    # in the mythryl-gtk-library-in-main-process.c callback_queue[]
	    # and then process that many.
	    #
	    # Note that more callbacks may get entered
	    # into that queue as we do so:  We
	    # deliberately do not process any such
	    # added callbacks in order to avoid the
	    # risk of getting into a loop that might
	    # cycle-starve other computations:
	    #
	    loop (number_of_queued_callbacks ())
	    where
		fun loop 0 => ();

		    loop i
			=>
			{   run_one_callback();
			    loop (i - 1);
			};
		end

		also
		fun run_one_callback ()
		    =
		    {   callback_type = type_of_next_queued_callback ();
			#
			if (callback_type == queued_void_callback)
			    #
			    callback_id = get_queued_void_callback ();

			    case (imp::get (*session.callback_map.void, callback_id))
				#
				THE callback =>  callback ();
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_bool_callback)
			    #
			    (get_queued_bool_callback ())
				->
			        (callback_id, bool);

			    case (imp::get (*session.callback_map.bool, callback_id))
				#
				THE callback =>  callback bool;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_float_callback)
			    #
			    (get_queued_float_callback ())
				->
			        (callback_id, float);

			    case (imp::get (*session.callback_map.float, callback_id))
				#
				THE callback =>  callback float;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_button_press_callback)
			    #
			    (get_queued_button_press_callback ())
				->
			        (callback_id, window, button, x, y, time, modifiers);


			    # Args are:
			    #     window receiving the event
			    #     button pressed;
			    #     pointer x-coord;
			    #     pointer y-coord;
			    #     event time in milliseconds; and
			    #     bitbag of modifier keys.

			    args = { window, button, x, y, time, modifiers =>  int_to_modifier_list modifiers };

			    case (imp::get (*session.callback_map.button_event, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_key_press_callback)
			    #
			    (get_queued_key_press_callback ())
				->
			        (callback_id, key, keycode, time, modifiers);


			    # Args are:
			    #     key;
			    #     keycode;
			    #     millisecond time;
			    #     modifiers.

			    args = { key, keycode, time, modifiers => int_to_modifier_list modifiers };

			    case (imp::get (*session.callback_map.key_event, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_motion_notify_callback)
			    #
			    (get_queued_motion_notify_callback())
				->
			        (callback_id, window, time, x, y, modifiers, is_hint);


			    # Args are:
			    #     window which received the event;
			    #     millisecond-accurate sample time;
			    #     pointer x-coord; and
			    #     pointer y-coord.

			    args = { window,
				     time,
				     x,
				     y,
				     modifiers =>  int_to_modifier_list  modifiers,
				     is_hint
				   };

			    case (imp::get (*session.callback_map.motion_event, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_expose_callback)
			    #
			    (get_queued_expose_callback ())
				->
			        (callback_id, window, count, x, y, wide, high);


			    # 'count' is count of following expose events.

			    args = { window, count, x, y, wide, high };

			    case (imp::get (*session.callback_map.expose_event, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;


			elif (callback_type == queued_configure_callback)
			    #
			    (get_queued_configure_callback ())
				->
			        (callback_id, window, x, y, wide, high);

			    args = { window, x, y, wide, high };

			    case (imp::get (*session.callback_map.configure_event, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			else
			    raise exception DIE (sprintf "run_one_callback: Internal error: unsupported callback_type %d" callback_type);
			fi;
		    };			 	# fun run_one_callback
	    end;					# where



    #################################################################################################
    # The following stuff gets built from
    #     build-a: plain-fn
    #     fn-name:
    #     fn-type:
    #     libcall:
    # paragraphs in
    #     src/opt/gtk/etc/gtk-construction.plan
    # via logic in
    #     src/lib/make-library-glue/make-library-glue.pkg
    # viz:
    #     build_plain_fn
    #  -> build_fun_definition_for_'xxx_client_driver_for_library_in_main_process_pkg'
    #  -> to_xxx_client_driver_for_library_in_main_process_pkg
    #
    # Do not edit this or following lines --- they are autobuilt.  (patchname="body")

    #                  Session -> Widget                                                      # gtk-client.api type
    my make_window:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_window" };


    #                (Session, String) -> Widget                                              # gtk-client.api type
    my make_label:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_label" };


    #                                (Session, Widget, String) -> Int                         # gtk-client.api type
    my make_status_bar_context_id:   (Session, Int/*Widget*/, String) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_status_bar_context_id" };


    #                Session -> Widget                                                        # gtk-client.api type
    my make_menu:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_menu" };


    #                       Session -> Widget                                                 # gtk-client.api type
    my make_option_menu:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_option_menu" };


    #                    Session -> Widget                                                    # gtk-client.api type
    my make_menu_bar:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_bar" };


    #                     Session -> Widget                                                   # gtk-client.api type
    my make_combo_box:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_combo_box" };


    #                          Session -> Widget                                              # gtk-client.api type
    my make_text_combo_box:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_text_combo_box" };


    #                (Session, String) -> Widget                                              # gtk-client.api type
    my make_frame:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_frame" };


    #                  Session -> Widget                                                      # gtk-client.api type
    my make_button:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_button" };


    #                            (Session, String) -> Widget                                  # gtk-client.api type
    my make_button_with_label:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_button_with_label" };


    #                               (Session, String) -> Widget                               # gtk-client.api type
    my make_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_button_with_mnemonic" };


    #                         Session -> Widget                                               # gtk-client.api type
    my make_toggle_button:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_toggle_button" };


    #                                   (Session, String) -> Widget                           # gtk-client.api type
    my make_toggle_button_with_label:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_toggle_button_with_label" };


    #                                      (Session, String) -> Widget                        # gtk-client.api type
    my make_toggle_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_toggle_button_with_mnemonic" };


    #                        Session -> Widget                                                # gtk-client.api type
    my make_check_button:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_check_button" };


    #                                  (Session, String) -> Widget                            # gtk-client.api type
    my make_check_button_with_label:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_check_button_with_label" };


    #                                     (Session, String) -> Widget                         # gtk-client.api type
    my make_check_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_check_button_with_mnemonic" };


    #                     Session -> Widget                                                   # gtk-client.api type
    my make_menu_item:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_item" };


    #                               (Session, String) -> Widget                               # gtk-client.api type
    my make_menu_item_with_label:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_item_with_label" };


    #                                  (Session, String) -> Widget                            # gtk-client.api type
    my make_menu_item_with_mnemonic:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_item_with_mnemonic" };


    #                              Session -> Widget                                          # gtk-client.api type
    my make_first_radio_button:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_first_radio_button" };


    #                            (Session, Widget) -> Widget                                  # gtk-client.api type
    my make_next_radio_button:   (Session, Int/*Widget*/) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_next_radio_button" };


    #                                        (Session, String) -> Widget                      # gtk-client.api type
    my make_first_radio_button_with_label:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_first_radio_button_with_label" };


    #                                       (Session, Widget, String) -> Widget               # gtk-client.api type
    my make_next_radio_button_with_label:   (Session, Int/*Widget*/, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_next_radio_button_with_label" };


    #                                           (Session, String) -> Widget                   # gtk-client.api type
    my make_first_radio_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_first_radio_button_with_mnemonic" };


    #                                          (Session, Widget, String) -> Widget            # gtk-client.api type
    my make_next_radio_button_with_mnemonic:   (Session, Int/*Widget*/, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_next_radio_button_with_mnemonic" };


    #                (Session, Arrow_Direction, Shadow_Style) -> Widget                       # gtk-client.api type
    my make_arrow:   (Session, Int, Int) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_arrow" };


    #               (Session, Widget, Arrow_Direction, Shadow_Style) -> Void                  # gtk-client.api type
    my set_arrow:   (Session, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_arrow" };


    #                         (Session, Bool, Int)   ->   Widget                              # gtk-client.api type
    my make_horizontal_box:   (Session, Bool, Int) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_box" };


    #                       (Session, Bool, Int)   ->   Widget                                # gtk-client.api type
    my make_vertical_box:   (Session, Bool, Int) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_box" };


    #                                 Session -> Widget                                       # gtk-client.api type
    my make_horizontal_button_box:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_button_box" };


    #                               Session -> Widget                                         # gtk-client.api type
    my make_vertical_button_box:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_button_box" };


    #                 { session: Session,   rows: Int,   cols: Int,   homogeneous: Bool }   ->   Widget   # gtk-client.api type
    my make_table:   (Session, Int, Int, Bool) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_table" };


    #                     Session -> Widget                                                   # gtk-client.api type
    my make_event_box:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_event_box" };


    #                          (Session, String) -> Widget                                    # gtk-client.api type
    my make_image_from_file:   (Session, String) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_image_from_file" };


    #                                Session -> Widget                                        # gtk-client.api type
    my make_horizontal_separator:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_separator" };


    #                              Session -> Widget                                          # gtk-client.api type
    my make_vertical_separator:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_separator" };


    #                            Session -> Widget                                            # gtk-client.api type
    my make_layout_container:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_layout_container" };


    #                 { session: Session,  layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk-client.api type
    my layout_put:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "layout_put" };


    #                  { session: Session, layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk-client.api type
    my layout_move:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "layout_move" };


    #                           Session -> Widget                                             # gtk-client.api type
    my make_fixed_container:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_fixed_container" };


    #                { session: Session, layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk-client.api type
    my fixed_put:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "fixed_put" };


    #                 { session: Session, layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk-client.api type
    my fixed_move:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "fixed_move" };


    #                      { session: Session,   value: Float,   lower: Float,   upper: Float,   step_increment: Float,   page_increment: Float,   page_size: Float }   ->   Widget   # gtk-client.api type
    my make_adjustment:   (Session, Float, Float, Float, Float, Float, Float) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_adjustment" };


    #                    { session: Session, horizontal_adjustment: Null_Or(Widget), vertical_adjustment: Null_Or(Widget) } -> Widget   # gtk-client.api type
    my make_viewport:   (Session, Int/*Widget*/, Int/*Widget*/) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_viewport" };


    #                           { session: Session, horizontal_adjustment: Null_Or(Widget), vertical_adjustment: Null_Or(Widget) } -> Widget   # gtk-client.api type
    my make_scrolled_window:   (Session, Int/*Widget*/, Int/*Widget*/) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_scrolled_window" };


    #                            Session -> Widget                                            # gtk-client.api type
    my make_horizontal_ruler:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_ruler" };


    #                          Session -> Widget                                              # gtk-client.api type
    my make_vertical_ruler:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_ruler" };


    #                             (Session, Null_Or(Widget)) -> Widget                        # gtk-client.api type
    my make_vertical_scrollbar:   (Session, Int/*Widget*/) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_scrollbar" };


    #                               (Session, Null_Or(Widget)) -> Widget                      # gtk-client.api type
    my make_horizontal_scrollbar:   (Session, Int/*Widget*/) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_scrollbar" };


    #                         (Session, Null_Or(Widget)) -> Widget                            # gtk-client.api type
    my make_vertical_scale:   (Session, Int/*Widget*/) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_scale" };


    #                           (Session, Null_Or(Widget)) -> Widget                          # gtk-client.api type
    my make_horizontal_scale:   (Session, Int/*Widget*/) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_scale" };


    #                                     { session: Session, min: Float, max: Float, step: Float } -> Widget   # gtk-client.api type
    my make_vertical_scale_with_range:   (Session, Float, Float, Float) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_scale_with_range" };


    #                                       { session: Session, min: Float, max: Float, step: Float } -> Widget   # gtk-client.api type
    my make_horizontal_scale_with_range:   (Session, Float, Float, Float) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_scale_with_range" };


    #                        Session -> Widget                                                # gtk-client.api type
    my make_drawing_area:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_drawing_area" };


    #                  { session: Session, window: Widget, wide: Int, high: Int } -> Widget   # gtk-client.api type
    my make_pixmap:   (Session, Int/*Widget*/, Int, Int) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_pixmap" };


    #                      Session -> Widget                                                  # gtk-client.api type
    my make_status_bar:   (Session) -> Int /*new Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "make_status_bar" };


    #                             (Session, Widget, Int, String) -> Int                       # gtk-client.api type
    my push_text_on_status_bar:   (Session, Int/*Widget*/, Int, String) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "push_text_on_status_bar" };


    #                             (Session, Widget, Int) -> Void                              # gtk-client.api type
    my pop_text_off_status_bar:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "pop_text_off_status_bar" };


    #                                  { session: Session,   status_bar: Widget,   context: Int,   message: Int } -> Void   # gtk-client.api type
    my remove_text_from_status_bar:   (Session, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "remove_text_from_status_bar" };


    #               { session: Session,   box: Widget,   kid: Widget,   pack: Pack_From,   expand: Bool,   fill: Bool,   padding: Int } -> Void   # gtk-client.api type
    my pack_box:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Bool, Bool, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "pack_box" };


    #                        { session: Session,   menu: Widget,   kid: Widget } -> Void      # gtk-client.api type
    my menu_shell_append:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "menu_shell_append" };


    #                      { session: Session,   menu: Widget,   kid: Widget } -> Void        # gtk-client.api type
    my menu_bar_append:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "menu_bar_append" };


    #                              (Session, Widget, String) -> Void                          # gtk-client.api type
    my append_text_to_combo_box:   (Session, Int/*Widget*/, String) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "append_text_to_combo_box" };


    #                           { session: Session,   option_menu: Widget,   menu: Widget } -> Void   # gtk-client.api type
    my set_option_menu_menu:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_option_menu_menu" };


    #                                (Session, Widget, String) -> Void                        # gtk-client.api type
    my set_text_tooltip_on_widget:   (Session, Int/*Widget*/, String) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_text_tooltip_on_widget" };


    #                      (Session, Widget, Metric) -> Void                                  # gtk-client.api type
    my set_ruler_metric:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_ruler_metric" };


    #                      { session: Session,   ruler: Widget,   lower: Float,   upper: Float,   position: Float,   max_size: Float } -> Void   # gtk-client.api type
    my set_ruler_range:   (Session, Int/*Widget*/, Float, Float, Float, Float) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_ruler_range" };


    #                           { session: Session,   window: Widget,   horizontal_scrollbar: Scrollbar_Policy,   vertical_scrollbar: Scrollbar_Policy } -> Void   # gtk-client.api type
    my set_scrollbar_policy:   (Session, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_scrollbar_policy" };


    #                     { session: Session,   drawable: Widget,   gcontext: Widget,   filled:	Bool,   x: Int,   y: Int,   wide: Int,   high: Int } -> Void   # gtk-client.api type
    my draw_rectangle:   (Session, Int/*Widget*/, Int/*Widget*/, Bool, Int, Int, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "draw_rectangle" };


    #                    { session: Session,   drawable: Widget,   gcontext: Widget,   from: Widget,   from_x:	Int,   from_y: Int,   to_x: Int,   to_y: Int,   wide: Int,   high: Int } -> Void   # gtk-client.api type
    my draw_drawable:   (Session, Int/*Widget*/, Int/*Widget*/, Int/*Widget*/, Int, Int, Int, Int, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "draw_drawable" };


    #                   { session: Session,   widget:	Widget,   x: Int,   y: Int,   wide: Int,   high: Int } -> Void   # gtk-client.api type
    my queue_redraw:   (Session, Int/*Widget*/, Int, Int, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "queue_redraw" };


    #                  (Session, Widget) -> Void                                              # gtk-client.api type
    my press_button:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "press_button" };


    #                    (Session, Widget) -> Void                                            # gtk-client.api type
    my release_button:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "release_button" };


    #                  (Session, Widget) -> Void                                              # gtk-client.api type
    my click_button:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "click_button" };


    #                  (Session, Widget) -> Void                                              # gtk-client.api type
    my enter_button:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "enter_button" };


    #                  (Session, Widget) -> Void                                              # gtk-client.api type
    my leave_button:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "leave_button" };


    #                 (Session, Widget) -> Void                                               # gtk-client.api type
    my show_widget:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "show_widget" };


    #                      (Session, Widget) -> Void                                          # gtk-client.api type
    my show_widget_tree:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "show_widget_tree" };


    #                    (Session, Widget) -> Void                                            # gtk-client.api type
    my destroy_widget:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "destroy_widget" };


    #                         (Session, Widget)   -> Void                                     # gtk-client.api type
    my emit_changed_signal:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "emit_changed_signal" };


    #                      (Session, Widget)   -> Void                                        # gtk-client.api type
    my pop_up_combo_box:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "pop_up_combo_box" };


    #                        (Session, Widget) -> Void                                        # gtk-client.api type
    my pop_down_combo_box:   (Session, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "pop_down_combo_box" };


    #                         (Session, Widget, String)   -> Void                             # gtk-client.api type
    my set_combo_box_title:   (Session, Int/*Widget*/, String) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_combo_box_title" };


    #                      (Session, Widget, String) -> Void                                  # gtk-client.api type
    my set_window_title:   (Session, Int/*Widget*/, String) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_window_title" };


    #                             (Session, Widget, (Int,Int)) -> Void                        # gtk-client.api type
    my set_window_default_size:   (Session, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_window_default_size" };


    #                             (Session, Widget, (Int,Int)) -> Void                        # gtk-client.api type
    my set_minimum_widget_size:   (Session, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_minimum_widget_size" };


    #                      (Session, Widget, Int) -> Void                                     # gtk-client.api type
    my set_border_width:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_border_width" };


    #                              (Session, Widget, Bool) -> Void                            # gtk-client.api type
    my set_event_box_visibility:   (Session, Int/*Widget*/, Bool) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_event_box_visibility" };


    #                           { session: Session, widget: Widget, x: Float, y: Float } -> Void   # gtk-client.api type
    my set_widget_alignment:   (Session, Int/*Widget*/, Float, Float) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_widget_alignment" };


    #                       (Session, Widget, List( Event_Mask )) -> Void                     # gtk-client.api type
    my set_widget_events:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_widget_events" };


    #                     (Session, Widget, String) -> Void                                   # gtk-client.api type
    my set_widget_name:   (Session, Int/*Widget*/, String) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_widget_name" };


    #                             (Session, Widget, Justification) -> Void                    # gtk-client.api type
    my set_label_justification:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_label_justification" };


    #                             (Session, Widget, Bool) -> Void                             # gtk-client.api type
    my set_label_line_wrapping:   (Session, Int/*Widget*/, Bool) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_label_line_wrapping" };


    #                          (Session, Widget, String) -> Void                              # gtk-client.api type
    my set_label_underlines:   (Session, Int/*Widget*/, String) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_label_underlines" };


    #                              (Session, Widget, Position_Type) -> Void                   # gtk-client.api type
    my set_scale_value_position:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_scale_value_position" };


    #                          (Session, Widget, Bool) -> Void                                # gtk-client.api type
    my set_draw_scale_value:   (Session, Int/*Widget*/, Bool) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_draw_scale_value" };


    #                                  (Session, Widget) -> Int                               # gtk-client.api type
    my get_scale_value_digits_shown:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_scale_value_digits_shown" };


    #                                  (Session, Widget, Int)  -> Void                        # gtk-client.api type
    my set_scale_value_digits_shown:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_scale_value_digits_shown" };


    #                             (Session, Widget, Update_Policy) -> Void                    # gtk-client.api type
    my set_range_update_policy:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_range_update_policy" };


    #                             (Session, Widget) -> Bool                                   # gtk-client.api type
    my get_toggle_button_state:   (Session, Int/*Widget*/) -> Bool
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_toggle_button_state" };


    #                             (Session, Widget, Bool) -> Void                             # gtk-client.api type
    my set_toggle_button_state:   (Session, Int/*Widget*/, Bool) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_toggle_button_state" };


    #                          (Session, Widget) -> Float                                     # gtk-client.api type
    my get_adjustment_value:   (Session, Int/*Widget*/) -> Float
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_adjustment_value" };


    #                          (Session, Widget, Float) -> Void                               # gtk-client.api type
    my set_adjustment_value:   (Session, Int/*Widget*/, Float) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_adjustment_value" };


    #                                (Session, Widget) -> Widget                              # gtk-client.api type
    my get_white_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_white_graphics_context" };


    #                                (Session, Widget) -> Widget                              # gtk-client.api type
    my get_black_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_black_graphics_context" };


    #                                             (Session, Widget) -> Widget                 # gtk-client.api type
    my get_current_foreground_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_current_foreground_graphics_context" };


    #                                             (Session, Widget) -> Widget                 # gtk-client.api type
    my get_current_background_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_current_background_graphics_context" };


    #                       (Session, Widget) -> Widget                                       # gtk-client.api type
    my get_widget_window:   (Session, Int/*Widget*/) -> Int /*Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_widget_window" };


    #              { session: Session,   mom: Widget,   kid: Widget } -> Void                 # gtk-client.api type
    my add_kid:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "add_kid" };


    #                              { session: Session,   window: Widget,   kid: Widget } -> Void   # gtk-client.api type
    my add_scrolled_window_kid:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "add_scrolled_window_kid" };


    #                    { session: Session,   table: Widget,   kid: Widget,   left: Int,   right: Int,   top: Int,   bottom: Int } -> Void   # gtk-client.api type
    my add_table_kid:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "add_table_kid" };


    #                     { session: Session,   table: Widget,   kid: Widget,   left: Int,   right: Int,   top: Int,   bottom: Int,   xoptions: List( Table_Attach_Option ),   yoptions: List( Table_Attach_Option ),   xpadding: Int,   ypadding: Int }   ->   Void   # gtk-client.api type
    my add_table_kid2:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int, Int, Int, Int, Int, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "add_table_kid2" };


    #                                      (Session, Widget) -> Widget                        # gtk-client.api type
    my get_viewport_vertical_adjustment:   (Session, Int/*Widget*/) -> Int /*Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_viewport_vertical_adjustment" };


    #                                        (Session, Widget) -> Widget                      # gtk-client.api type
    my get_viewport_horizontal_adjustment:   (Session, Int/*Widget*/) -> Int /*Widget*/
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "get_viewport_horizontal_adjustment" };


    #                            { session: Session, table: Widget, row: Int, spacing: Int } -> Void   # gtk-client.api type
    my set_table_row_spacing:   (Session, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_table_row_spacing" };


    #                            { session: Session, table: Widget, col: Int, spacing: Int } -> Void   # gtk-client.api type
    my set_table_col_spacing:   (Session, Int/*Widget*/, Int, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_table_col_spacing" };


    #                            (Session, Widget, Int) -> Void                               # gtk-client.api type
    my set_table_row_spacings:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_table_row_spacings" };


    #                            (Session, Widget, Int) -> Void                               # gtk-client.api type
    my set_table_col_spacings:   (Session, Int/*Widget*/, Int) -> Void
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_table_col_spacings" };


    #                           Session -> Widget -> Void_Callback -> Void                    # gtk-client.api type
    my set_clicked_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_clicked_callback" };


    #                           Session -> Widget -> Void_Callback -> Void                    # gtk-client.api type
    my set_pressed_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_pressed_callback" };


    #                           Session -> Widget -> Void_Callback -> Void                    # gtk-client.api type
    my set_release_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_release_callback" };


    #                         Session -> Widget -> Void_Callback -> Void                      # gtk-client.api type
    my set_enter_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_enter_callback" };


    #                         Session -> Widget -> Void_Callback -> Void                      # gtk-client.api type
    my set_leave_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_leave_callback" };


    #                            Session -> Widget -> Void_Callback -> Void                   # gtk-client.api type
    my set_activate_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_activate_callback" };


    #                           Session -> Widget -> Void_Callback -> Void                    # gtk-client.api type
    my set_destroy_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_destroy_callback" };


    #                           Session -> Widget -> Void_Callback -> Void                    # gtk-client.api type
    my set_realize_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_realize_callback" };


    #                                      Session -> Widget -> Button_Event_Callback -> Void   # gtk-client.api type
    my set_button_press_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_button_press_event_callback" };


    #                                        Session -> Widget -> Void_Callback -> Void       # gtk-client.api type
    my set_button_release_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_button_release_event_callback" };


    #                                Session -> Widget -> Void_Callback -> Void               # gtk-client.api type
    my set_scroll_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_scroll_event_callback" };


    #                                       Session -> Widget -> Motion_Event_Callback -> Void   # gtk-client.api type
    my set_motion_notify_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_motion_notify_event_callback" };


    #                                Session -> Widget -> Void_Callback -> Void               # gtk-client.api type
    my set_delete_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_delete_event_callback" };


    #                                Session -> Widget -> Expose_Event_Callback -> Void       # gtk-client.api type
    my set_expose_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_expose_event_callback" };


    #                                   Session -> Widget -> Key_Event_Callback -> Void       # gtk-client.api type
    my set_key_press_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_key_press_event_callback" };


    #                                     Session -> Widget -> Void_Callback -> Void          # gtk-client.api type
    my set_key_release_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_key_release_event_callback" };


    #                                      Session -> Widget -> Void_Callback -> Void         # gtk-client.api type
    my set_enter_notify_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_enter_notify_event_callback" };


    #                                      Session -> Widget -> Void_Callback -> Void         # gtk-client.api type
    my set_leave_notify_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_leave_notify_event_callback" };


    #                                   Session -> Widget -> Configure_Event_Callback -> Void   # gtk-client.api type
    my set_configure_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_configure_event_callback" };


    #                                  Session -> Widget -> Void_Callback -> Void             # gtk-client.api type
    my set_focus_in_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_focus_in_event_callback" };


    #                                   Session -> Widget -> Void_Callback -> Void            # gtk-client.api type
    my set_focus_out_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_focus_out_event_callback" };


    #                             Session -> Widget -> Void_Callback -> Void                  # gtk-client.api type
    my set_map_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_map_event_callback" };


    #                               Session -> Widget -> Void_Callback -> Void                # gtk-client.api type
    my set_unmap_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_unmap_event_callback" };


    #                                         Session -> Widget -> Void_Callback -> Void      # gtk-client.api type
    my set_property_notify_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_property_notify_event_callback" };


    #                                         Session -> Widget -> Void_Callback -> Void      # gtk-client.api type
    my set_selection_clear_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_selection_clear_event_callback" };


    #                                           Session -> Widget -> Void_Callback -> Void    # gtk-client.api type
    my set_selection_request_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_selection_request_event_callback" };


    #                                          Session -> Widget -> Void_Callback -> Void     # gtk-client.api type
    my set_selection_notify_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_selection_notify_event_callback" };


    #                                      Session -> Widget -> Void_Callback -> Void         # gtk-client.api type
    my set_proximity_in_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_proximity_in_event_callback" };


    #                                       Session -> Widget -> Void_Callback -> Void        # gtk-client.api type
    my set_proximity_out_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_proximity_out_event_callback" };


    #                                Session -> Widget -> Void_Callback -> Void               # gtk-client.api type
    my set_client_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_client_event_callback" };


    #                                   Session -> Widget -> Void_Callback -> Void            # gtk-client.api type
    my set_no_expose_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_no_expose_event_callback" };


    #                                      Session -> Widget -> Void_Callback -> Void         # gtk-client.api type
    my set_window_state_event_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_window_state_event_callback" };


    #                           Session -> Widget -> Bool_Callback -> Void                    # gtk-client.api type
    my set_toggled_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_toggled_callback" };


    #                                 Session -> Widget -> Float_Callback -> Void             # gtk-client.api type
    my set_value_changed_callback:   (Session, Int/*Widget*/) -> Int
        =
        ci::find_c_function { lib_name => "gtk", fun_name => "set_value_changed_callback" };

    # Do not edit this or preceding lines --- they are autobuilt.
    #################################################################################################


	#
	fun make_session  callback_map
	    =
	    {   session = { callback_map };							# At the moment we actually have no per-session state of our own, just the callback maps from our client.
		#
		init ();

		session;
	    };

	#
	fun get_widget_allocation (session, widget)
	    =
	    do_get_widget_allocation widget;

	#
	fun get_window_pointer (session, window)
	    =
	    do_get_window_pointer window;

	#
	fun make_dialog session
	    =
	    do_make_dialog ();

	#
	fun unref_object (session, widget)
	    =
	    do_unref_object widget;

	#
	fun quit_eventloop  session
	    =
	    winix__premicrothread::process::exit
		winix__premicrothread::process::success;

	#
	fun run_eventloop_once  (session, block_until_event)
	    =
	    {   result = do_run_eventloop_once  block_until_event;
		run_pending_callbacks  session;
		result;
	    };

	#
	fun run_eventloop_indefinitely  session
	    =
	    {   # Actually calling
		#
		#     gtk_main();
		#
		# at the mythryl-gtk-library-in-main-process.c level won't do
		# because then we have no way to run
		# Mythryl-level callbacks short of
		# implementing calls from C into
		# Mythryl, which is a can of worms
		# best not opened.
		#
		# So instead we loop at this level:
		#
		run_eventloop_once (session, /*block_until_event=*/TRUE);
		run_eventloop_indefinitely  session;
	    };

    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(my \\)"			 		 #
# End:									 #
##########################################################################



## Code by Jeff Prothero: Copyright (c) 2010-2015,
## released per terms of SMLNJ-COPYRIGHT.
