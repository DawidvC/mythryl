## machine-properties.api

# Compiled by:
#     src/lib/compiler/core.sublib



# This api contains various machine- and backend-specific
# parameters. 
#
# When should a parameter be put in this api?
# Only when changing it will yield incompatible code.
# Parameters that change optimization algorithms but
# yield compatible code should not go here.       -- Andrew Appel


# This api is implemented by:
#
#     src/lib/compiler/back/low/main/main/machine-properties-default.pkg
#     src/lib/compiler/back/low/main/intel32/machine-properties-intel32.pkg
#     src/lib/compiler/back/low/main/pwrpc32/machine-properties-pwrpc32.pkg
#     src/lib/compiler/back/low/main/sparc32/machine-properties-sparc32.pkg

stipulate
    package sma =  supported_architectures;					# supported_architectures	is from   src/lib/compiler/front/basics/main/supported-architectures.pkg
herein
    api Machine_Properties {
	#
	machine_architecture:  sma::Supported_Architectures;			# PWRPC32/SPARC32/INTEL32.

	framesize:  Int;

	# Code generator flags:
	#
	polling:		Bool;
	unboxed_floats:		Bool;
	representations:	Bool;
	new_closure:		Bool;
	untagged_int:		Bool;		# Represent all integers without tags?
	#
	num_int_regs:		Int;		# Number of int   registers used by Mythryl.
	num_float_regs:		Int;		# Number of float registers used by Mythryl .
	num_arg_regs:		Int;		# Number of registers used to pass args. 
	max_rep_regs:		Int;		# Rename or eliminate this.
	num_float_arg_regs:	Int;		# Number of float registers used for args. 
	num_callee_saves:	Int;
	num_float_callee_saves:	Int;

	# Machine representations:
	#
	Value_Tag = {   tagbits:    Int,	# Number of tag bits.
			tagval:	    Int		# Value  of tag bits.
		    };

	int_tag:	Value_Tag;		# Tag for tagged integer values.
	ptr_tag:	Value_Tag;		# Tag for pointers.
	tagword_tag:	Value_Tag;		# Tag for heapchunk tagwords (first word in heapchunk).

	# Heapchunk tagwords, ultimately from   src/c/h/heap-tags.h 
	#
	package heap_tags:  Heap_Tags;		# Heap_Tags	is from   src/lib/compiler/back/low/main/main/heap-tags.api

	value_size:  Int;			# Number of bytes for a Mythryl value.
	char_size:  Int;			# Number of bytes for a char.
	float_size_in_bytes:		Int;	# Number of bytes of the default float type.
	float_align:  Bool;			# If TRUE, floats are float_size aligned.

	big_endian:  Bool;			# TRUE iff this is a big-endian machine.

	spill_area_size:		Int;	# Size-in-bytes of the area for spilling registers. 
	initial_spill_offset:		Int; 	# Offset of the first spill location.

	run_heapcleaner__offset:	Int;	# Offset relative to framepointer of pointer to function which starts a heapcleaning ("garbage collection").
	const_base_pointer_reg_offset:		Int;

	quasi_stack:			Bool;	# Defaults to FALSE.
	quasi_free:			Bool;	# Defaults to FALSE.
	quasi_frame_size:		Int;	# Default  to 7.

	new_list_rep:			Bool;	# Defaults to FALSE.
	list_cell_size:			Int;    # Defaults to 2.

	float_reg_params:		Bool;	# For old-style code generator; defaults to TRUE.

	write_allocate_hack:		Bool;	# Defaults to FALSE.

	# Get "conreps" into here eventually.
	# Don't want to do it now, because it would
	# require generic-ing the whole front end.  -- Andrew Appel XXX BUGGO FIXME

	fixed_arg_passing:	Bool;
	    #
	    # Use fixed argument passing registers for all-callers-known
	    # functions that require garbage collection.
	    #
	    # This is only an issue on  the intel32 or machines that
	    # have registers implemented as memory locations -- that is,
	    # when at the call to the heapcleaner there are not enough
	    # registers to hold all the roots.
	    # 
	    # The correct way to solve this problem is to create a record of
	    # live variables inside the code that invokes the garbage collector  XXX BUGGO FIXME
	    # 
	    # 							-- Lal George.

	spill_rematerialization:  Bool;				#  Whether rematerialization of spill locations is performed .

	# For accessing the in_LIB7 flag etc.;
	# These values must be coordinated with
	# their respective runtime counterparts in:
	#
        #     task-and-hostthread-struct-field-offsets--autogenerated.h
	# and
        #     src/c/machine-dependent/prim.sparc32.asm
	#     src/c/machine-dependent/prim.intel32.asm
	#     src/c/machine-dependent/prim.pwrpc32.asm
	#
	task_offset:		Int;		# within frame 
	hostthread_offtask:	Int;		# within Task    struct 
	in_lib7off_vsp:		Int;		# within Hostthread struct 
	limit_ptr_mask_off_vsp:	Int;		# within Hostthread struct 

	# On machines with a real frame pointer, there is no point in
	# attempting to omit a (virtual) frame pointer.  Example: Sparc32
	#
	framepointer_never_virtual:  Bool;		# Suppress omit-framepointer phase 

	# On machines where C arguments are allocated in the caller's frame
	# we pre-allot a large chunk of stack space for this purpose.
	# Example: PWRPC32
	#
	ccall_prealloc_argspace_in_bytes:  Null_Or(  Int );
    };										# api Machine_Properties 
end;

## COPYRIGHT (c) 1994 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2015,
## released per terms of SMLNJ-COPYRIGHT.
