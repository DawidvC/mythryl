## unparse-compiler-state.pkg

# Compiled by:
#     src/lib/compiler/core.sublib

stipulate
    package cms =  compiler_mapstack_set;				# compiler_mapstack_set		is from   src/lib/compiler/toplevel/compiler-state/compiler-mapstack-set.pkg
									# symbol			is from   src/lib/compiler/front/basics/map/symbol.pkg
									# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
									# variables_and_constructors	is from   src/lib/compiler/front/typer-stuff/deep-syntax/variables-and-constructors.pkg
									# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
									# symbolmapstack_entry		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack-entry.pkg

    package cps =  compiler_state;					# compiler_state		is from   src/lib/compiler/toplevel/interact/compiler-state.pkg

    package pp  =  standard_prettyprinter;				# standard_prettyprinter	is from   src/lib/prettyprint/big/src/standard-prettyprinter.pkg
									# prettyprint_symbolmapstack	is from   src/lib/compiler/front/typer-stuff/symbolmapstack/prettyprint-symbolmapstack.pkg

    Pp = pp::Pp;
herein

    package unparse_compiler_state
    :       Unparse_Compiler_State					# Unparse_Compiler_State	is from   src/lib/compiler/front/typer-stuff/symbolmapstack/unparse-compiler-state.api
    {

	fun unparse_compiler_mapstack_set
		(pp:  pp::Prettyprinter)
		(compiler_mapstack_set:  cms::Compiler_Mapstack_Set)
	    =
	    {
		include package  compiler_mapstack_set;

		pp.lit   "Symbol table";             pp.newline();
		pp.lit   "------------";             pp.newline();
		pp.newline();

		prettyprint_symbolmapstack::prettyprint_symbolmapstack
		    pp
		    (symbolmapstack_part  compiler_mapstack_set);

		pp.newline();
		pp.newline();
		pp.newline();
		pp.lit   "Linking table";            pp.newline();
		pp.lit   "-------------";            pp.newline();
		pp.newline();
		pp.lit   "(unimplemented)";          pp.newline();

		pp.newline();
		pp.newline();
		pp.newline();
		pp.lit   "Inlining table";           pp.newline();
		pp.lit   "--------------";           pp.newline();
		pp.newline();
		pp.lit   "(unimplemented)";          pp.newline();
	    };


	fun unparse_compiler_mapstack_set_reference
		#
		(pp:  pp::Prettyprinter)
		#
		(compiler_mapstack_set_reference:   cps::Compiler_Mapstack_Set_Jar)
	    =
	    unparse_compiler_mapstack_set  pp   (compiler_mapstack_set_reference.get_mapstack_set ());


	fun unparse_compiler_state
		(pp:  pp::Prettyprinter)
	    =
	    {   pp.lit   "Combined (top_level + base) compiler tableset";            pp.newline();
		pp.lit   "=============================================";            pp.newline();
		unparse_compiler_mapstack_set            pp  (cps::combined ());

		pp.newline();
		pp.newline();
		pp.newline();
		pp.lit   "Toplevel compiler tableset";            pp.newline();
		pp.lit   "==========================";            pp.newline();
		unparse_compiler_mapstack_set_reference  pp  (cps::get_top_level_pkg_etc_defs_jar ());

		pp.newline();
		pp.newline();
		pp.newline();
		pp.lit   "Base compiler tableset";            pp.newline();
		pp.lit   "======================";            pp.newline();
		unparse_compiler_mapstack_set_reference  pp  (cps::get_baselevel_pkg_etc_defs_jar ());

		pp.newline();
		pp.newline();
		pp.newline();
		pp.lit   "Pervasive compiler tableset";            pp.newline();
		pp.lit   "===========================";            pp.newline();
		unparse_compiler_mapstack_set_reference  pp  cps::pervasive_fun_etc_defs_jar;
	    };


	fun unparse_compiler_state_to_file
	    (prettyprint_filename:  String)
	    =
	    {
		pp  = standard_prettyprinter::make_standard_prettyprinter_into_file  prettyprint_filename  [];

#		pp = pp.pp;

		unparse_compiler_state  pp;

		pp.newline();
		pp.newline();
		pp.newline();
		pp.lit   "This file generated by unparse_compiler_state_to_file  from";
                pp.newline();
		pp.lit   "    src/lib/compiler/front/typer-stuff/symbolmapstack/unparse-compiler-state.pkg";
		pp.newline();

		pp.flush ();
		pp.close ();
	    };

    };
end;














##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2015,
## released per terms of SMLNJ-COPYRIGHT.
