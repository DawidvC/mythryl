## latex-print-symbolmapstack.pkg

# Compiled by:
#     src/lib/compiler/core.sublib

# Invoked from src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-compiler-state.pkg

# This is a clone of prettyprint-symbolmapstack.pkg
# specialized to produce LaTeX output intended to be
# run through Hevea to produce online HTML docs of
# our interfaces.
#

stipulate
    include package   symbolmapstack_entry;						# symbolmapstack_entry		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack-entry.pkg
    #
    package mld =  module_level_declarations;					# module_level_declarations	is from   src/lib/compiler/front/typer-stuff/modules/module-level-declarations.pkg
    package pp  =  standard_prettyprinter;					# standard_prettyprinter	is from   src/lib/prettyprint/big/src/standard-prettyprinter.pkg
    package psx =  posixlib;							# posixlib			is from   src/lib/std/src/psx/posixlib.pkg
    package sy  =  symbol;							# symbol                        is from   src/lib/compiler/front/basics/map/symbol.pkg
    package syx	=  symbolmapstack;						# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
    package tdt =  type_declaration_types;					# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package vac =  variables_and_constructors;					# variables_and_constructors	is from   src/lib/compiler/front/typer-stuff/deep-syntax/variables-and-constructors.pkg

    Pp = pp::Pp;
herein


    package   latex_print_symbolmapstack
    :         Latex_Print_Symbolmapstack					# Latex_Print_Symbolmapstack	is from   src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.api
    {


										# latex_print_value		is from   src/lib/compiler/front/typer/print/latex-print-value.pkg
										# latex_print_type		is from   src/lib/compiler/front/typer/print/latex-print-type.pkg
										# latex_print_package_language	is from   src/lib/compiler/front/typer/print/latex-print-package-language.pkg


	fun is_file  filename
	    =
	    psx::stat::is_file (psx::stat  filename)
	    except
		_ = FALSE;

	# 2007-12-05: At the moment we are called only from
	#
	#   src/lib/compiler/toplevel/main/translate-raw-syntax-to-execode-g.pkg
	#
	fun latex_print_symbolmapstack
		(pp:Pp)                         # "pp" == "prettyprint (mill)"
		{ directory:       String,
		  filename_prefix: String,
		  filename_suffix: String
		}
		symbolmapstack
	    =
	    {    map
		     do_symbol_binding
		     symbolmapstack_contents; 

		 pp.newline();
	    }
	    where

		 symbolmapstack_contents                       # A list of (symbol, value) pairs.
		     = 
		     syx::to_sorted_list  symbolmapstack;


		 fun do_symbol_binding (symbol, binding)                    # symbol        is from   src/lib/compiler/front/basics/map/symbol.pkg
		     =
		     {
			 fun print_tagged_name ()
			      =
			      {   namespace =   sy::name_space_to_string  (sy::name_space symbol);
				  name      =                              sy::name       symbol;

				  pp.lit   (namespace + " " + name + ":  " );
			      };

			 backslash_latex_special_chars = latex_print_value::backslash_latex_special_chars;

			 fun print_name ()
			      =
			      {   name      =   sy::name       symbol;

				  pp.lit   name;
			      };

			 case binding

			       NAMED_VARIABLE             (v:   vac::Variable)
				   =>
				   latex_print_value::latex_print_variable
				       pp
				       (symbolmapstack, v);

			       NAMED_CONSTRUCTOR          (v:   tdt::Valcon)
				   =>
				   {   latex_print_value::latex_print_constructor
					   pp
					   symbolmapstack
					   v;

				       pp.lit   ";";
				   };

			       NAMED_TYPE                 (t:   tdt::Type)
				   =>
				   {   latex_print_type::latex_print_type
					   symbolmapstack                     # XXX BUGGO FIXME we need to standardize on "stream symbolmapstack" or "symbolmapstack stream" arg order.
					   pp
					   t;

				       pp.lit   ";";
				   };

			       NAMED_API                  (our_api:   mld::Api)
				   =>
				   {
				       # Open a separate   doc/tex/tmp*.tex
				       # output file for this api:
				       #  
				       api_name  =   sy::name       symbol;

				       # Filename for autogenerated content:
				       #
				       prettyprint_filepath
					   =
					   directory + "/"   +
					   filename_prefix   +
					   "api-"            +
					   api_name          +
					   filename_suffix;


				       # Filename for matching top-of-file manually generated content, if any:
				       #
				       top_manually_generated_content_filename
					   =
					   "top-"            +
					   "api-"            +
					   api_name          +
					   filename_suffix;
				       #
				       top_manually_generated_content_filepath
					   =
					   directory + "/"   +  top_manually_generated_content_filename;


				       # Filename for matching bottom-of-file manually generated content, if any:
				       #
				       bot_manually_generated_content_filename
					   =
					   "bot-"            +
					   "api-"            +
					   api_name          +
					   filename_suffix;
				       #
				       bot_manually_generated_content_filepath
					   =
					   directory + "/"   +  bot_manually_generated_content_filename;


				       pp  = standard_prettyprinter::make_standard_prettyprinter_into_file  prettyprint_filepath  [];

				       pps = pp.pp;


				       pp.lit  ("\\inde" + "x[api]{" + (backslash_latex_special_chars api_name) + "}");
				       pp.newline();

				       pp.lit  ("\\labe" + "l{api:"  + (backslash_latex_special_chars api_name) + "}");
				       pp.newline();

				       # Include top-of-file manually generated content if available:
				       #
				       if (is_file  top_manually_generated_content_filepath)
					   pp.newline();
					   pp.lit  ("\\in" + "put{" + top_manually_generated_content_filename + "}");                               pp.newline();      pp.newline();
					   pp.lit  "{\\tiny \\it The above information is manually maintained and may contain errors.}";            pp.newline();      pp.newline();
				       fi;  

				       pp.lit  ("\\begi" + "n{verbatim}");        # The break is to avoid confusing Hevea when it formats this file.
				       pp.newline();

				       # Upon return from next call, this will be a
				       # list of TeX index entry strings like
				       # "(backslash)index[fun]{foo}" or such:
				       #
				       index_entries = REF [];

				       latex_print_package_language::latex_print_api
					   pp
					   (our_api, symbolmapstack, /* max prettyprint recursion depth: */ 200, index_entries );

				       pp.newline();
				       pp.lit  ("\\en" + "d{verbatim}");          # The break is to avoid confusing Hevea when it formats this file.

				       # Print any index table entries generated during the above:
				       #
				       foreach *index_entries {.
					   pp.lit  #entry;
				       };

				       # Include bottom-of-file manually generated content if available:
				       #
				       if (is_file  bot_manually_generated_content_filepath)
					   pp.newline();
					   pp.lit  "{\\tiny \\it The following information is manually maintained and may contain errors.}";            pp.newline();      pp.newline();
					   pp.lit  ("\\in" + "put{" + bot_manually_generated_content_filename + "}");                                   pp.newline();
				       fi;  

				       pp.newline();
				       pp.newline();
				       pp.lit   "% This file generated by do_symbol_binding  from";                                                     pp.newline();
				       pp.lit   "%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg";           pp.newline();

				       pp.flush ();
				       pp.close ();
				   };

			       NAMED_PACKAGE              (our_pkg:   mld::Package)
				   =>
				   {
				       # Open a separate   doc/tex/tmp*.tex
				       # output file for this pkg:
				       #  
				       pkg_name  =   sy::name       symbol;

				       # Filename for autogenerated content:
				       #
				       prettyprint_filepath
					   =
					   directory + "/"   +
					   filename_prefix   +
					   "pkg-"            +
					   pkg_name          +
					   filename_suffix;

				       # Filename for matching top-of-file manually generated content, if any:
				       #
				       top_manually_generated_content_filename
					   =
					   "top-"            +
					   "pkg-"            +
					   pkg_name          +
					   filename_suffix;
				       #
				       top_manually_generated_content_filepath
					   =
					   directory + "/"   +  top_manually_generated_content_filename;

				       # Filename for matching bottom-of-file manually generated content, if any:
				       #
				       bot_manually_generated_content_filename
					   =
					   "bot-"            +
					   "pkg-"            +
					   pkg_name          +
					   filename_suffix;
				       #
				       bot_manually_generated_content_filepath
					   =
					   directory + "/"   +  bot_manually_generated_content_filename;

				       pp  = standard_prettyprinter::make_standard_prettyprinter_into_file  prettyprint_filepath  [];

				       pps = pp.pp;


				       pp.lit  ("\\inde" + "x[pkg]{" + (backslash_latex_special_chars pkg_name) + "}");
				       pp.newline();

				       pp.lit  ("\\labe" + "l{pkg:" + (backslash_latex_special_chars  pkg_name) + "}");
				       pp.newline();

				       # Include top-of-file manually generated content if available:
				       #
				       if (is_file  top_manually_generated_content_filepath)
					   pp.newline();
					   pp.lit  ("\\in" + "put{" + top_manually_generated_content_filename + "}");                               pp.newline();      pp.newline();
					   pp.lit  "{\\tiny \\it The above information is manually maintained and may contain errors.}";            pp.newline();      pp.newline();
				       fi;  

				       pp.lit  ("\\begi" + "n{verbatim}");        # The break is to avoid confusing Hevea when it formats this file.
				       pp.newline();

				       latex_print_package_language::latex_print_package
					   pp
					   (our_pkg, symbolmapstack, /* max prettyprint recursion depth: */ 200, /*currently unused index entry return channel:*/ REF []);

				       pp.newline();
				       pp.lit  ("\\en" + "d{verbatim}");          # The break is to avoid confusing Hevea when it formats this file.

				       # Include manually generated bottom-of-file content if available:
				       #
				       if (is_file  bot_manually_generated_content_filepath)
					   pp.newline();
					   pp.lit  "{\\tiny\\it The following information is manually maintained and may contain errors.}";             pp.newline();      pp.newline();
					   pp.lit  ("\\in" + "put{" + bot_manually_generated_content_filename + "}");                                   pp.newline();
				       fi;  

				       pp.newline();
				       pp.newline();
				       pp.lit   "% This file generated by do_symbol_binding  from";                                                     pp.newline();
				       pp.lit   "%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg";           pp.newline();

				       pp.flush ();
				       pp.close ();


    #                                   pp.newline();
    #                                  pp.lit  "package ";
    #                                   print_name ();      
    #                                  pp.newline();
    #                                  pp.lit  ":";
    #                                  pp.newline();
    #                                   latex_print_package_language::latex_print_package
    #                                      pp
    #                                       (m, symbolmapstack, /* max prettyprint recursion depth: */ 200);
				   };

			       NAMED_GENERIC_API          (m:   mld::Generic_Api)
				   =>
				   {   pp.newline();
				       pp.lit  "generic_api ";
				       print_name ();       
				       pp.newline();
				       pp.lit  ":";
				       pp.newline();
				       latex_print_package_language::latex_print_generic_api
					   pp
					   (m, symbolmapstack, /* max prettyprint recursion depth: */ 200, /*currently unused index entry return channel:*/ REF []);
				   };
    #                              print_tagged_name ();

			       NAMED_GENERIC              (m:   mld::Generic)
				   =>
				   {   pp.newline();
				       pp.lit  "generic ";
				       print_name ();       
				       pp.newline();
				       pp.lit  ":";
				       pp.newline();
				       latex_print_package_language::latex_print_generic
					   pp
					   (m, symbolmapstack, /* max prettyprint recursion depth: */ 200, /*currently unused index entry return channel:*/ REF []);
				   };
    #                              print_tagged_name ();

			       NAMED_FIXITY               (f:   fixity::Fixity)
				   =>
				   print_tagged_name ();
			  esac;     

			  pp.newline();
		     };                             # fun do_symbol_binding    in   fun prettyprint_symbolmapstack


	    end;
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.            #
#  ^C @ ^T hides all Text. (Leaves all headings.)                        #
#  ^C @ ^A shows All of file.                                            #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)     #
#  ^C @ ^I shows Immediate children of node.                             #
#  ^C @ ^S Shows all of a node.                                          #
#  ^C @ ^D hiDes all of a node.                                          #
#  ^HFoutline-mode gives more details.                                   #
#  (Or do ^HI and read emacs:outline mode.)                              #
#                                                                        #
# Local variables:                                                       #
# mode: outline-minor                                                    #
# outline-regexp: "[{ \t]*\\(fun \\)"                                    #
# End:                                                                   #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2015,
## released per terms of SMLNJ-COPYRIGHT.
