## lineeditor.pkg
#
# One line of textfile contents in a textpane display.
# 
# It may be that lineeditor, statusline and minibuffer
# could be a single package;  I've made them separate
# to give them a chance to diverge naturally if there
# is good reason for them to do so.
#
# See also:
#     src/lib/x-kit/widget/edit/textedit.pkg
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/statusline.pkg
#     src/lib/x-kit/widget/edit/minibuffer.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib





# This package gets used in:
#
#     

stipulate
    include package   threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    include package   geometry2d;						# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    #
    package chr =  char;							# char				is from   src/lib/std/src/char.pkg
    package evt =  gui_event_types;						# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package g2p =  gadget_to_pixmap;						# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package gd  =  gui_displaylist;						# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gt  =  guiboss_types;						# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package wt  =  widget_theme;						# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
    package wti =  widget_theme_imp;						# widget_theme_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/widget-theme-imp.pkg
    package r8  =  rgb8;							# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;								# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package wi  =  widget_imp;							# widget_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
    package g2d =  geometry2d;							# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;						# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg
    package mtx =  rw_matrix;							# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package pp  =  standard_prettyprint_mill;					# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package gtg =  guiboss_to_guishim;						# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2l =  editboss_to_lineeditor;					# editboss_to_lineeditor	is from   src/lib/x-kit/widget/edit/editboss-to-lineeditor.pkg
    package p2l =  textpane_to_lineeditor;					# textpane_to_lineeditor	is from   src/lib/x-kit/widget/edit/textpane-to-lineeditor.pkg
    package l2p =  lineeditor_to_textpane;					# lineeditor_to_textpane	is from   src/lib/x-kit/widget/edit/lineeditor-to-textpane.pkg
    package t2t =  textpane_to_textbuffer;					# textpane_to_textbuffer	is from   src/lib/x-kit/widget/edit/textpane-to-textbuffer.pkg
    package tpt =  textpane_types;						# textpane_types		is from   src/lib/x-kit/widget/edit/textpane-types.pkg
    package g2b =  gadget_to_editboss;						# gadget_to_editboss		is from   src/lib/x-kit/widget/edit/gadget-to-editboss.pkg
    package g2d =  geometry2d;							# geometry2d			is from   src/lib/std/2d/geometry2d.pkg

    package iuw =  issue_unique_widget_id;					# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg

    nb =  log::note_on_stderr;							# log				is from   src/lib/std/src/log.pkg

Dummy1 = p2l::Textpane_To_Lineeditor;	# XXX SUCKO DELETEME This is just to force compilation during initial development.
Dummy2 = b2l::Editboss_To_Lineeditor; 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package lineeditor
    :	    Lineeditor								# Lineeditor			is from   src/lib/x-kit/widget/leaf/lineeditor.api
    {
	Redraw_Fn_Arg
	    =
	    REDRAW_FN_ARG
	      {
		id:				iuw::Id,			# Unique id.
		doc:				String,
		frame_number:			Int,				# 1,2,3,... Purely for convenience of widget, guiboss-imp makes no use of this.
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Window rectangle in which to draw.
		popup_nesting_depth:		Int,				# 0 for gadgets on basewindow, 1 for gadgets on popup on basewindow, 2 for gadgets on popup on popup, etc.
		#
		duration_in_seconds:		Float,				# If state has changed look-imp should call note_changed_gadget_foreground() before this time is up. Also useful for motionblur.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		gadget_mode:			gt::Gadget_Mode,
		#
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		palette:			wt::Gadget_Palette,
		#
		default_redraw_fn:		Redraw_Fn,
		#
		state:				p2l::Linestate,
		cursor_on:			Bool,				# Tracks whether blinking cursor is currently in/visible.
		#
		fonts:				List(String),
		font_weight:			Null_Or(wt::Font_Weight),
		font_size:			Null_Or(Int)
	      }
	withtype
	Redraw_Fn
	  =
	  Redraw_Fn_Arg
	  ->
	  { displaylist:		gd::Gui_Displaylist,
	    point_in_gadget:		Null_Or(g2d::Point -> Bool),		# 
	    pixels_high_min:		Int,
	    pixels_wide_min:		Int
	  }
	  ;



	Mouse_Click_Fn_Arg
	    =
	    MOUSE_CLICK_FN_ARG							# Needs to be a sumtype because of recursive reference in default_mouse_click_fn.
	      { id:				iuw::Id,			# Unique id.
		doc:				String,
		event:				gt::Mousebutton_Event,		# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
		button:				evt::Mousebutton,		# Which mousebutton was pressed/released.
		point:				g2d::Point,			# Where the mouse was.
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		modifier_keys_state:		evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_mouse_click_fn:		Mouse_Click_Fn,
		#
		state:				Ref(p2l::Linestate),
		cursor_on:			Ref(Bool),			# Tracks whether blinking cursor is currently in/visible.
		#
		notify_statewatchers:		Void -> Void,			# 
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Click_Fn = Mouse_Click_Fn_Arg -> Void;



	Mouse_Drag_Fn_Arg
	    =
	    MOUSE_DRAG_FN_ARG
	      {
		id:				iuw::Id,			# Unique id.
		doc:				String,
		event_point:			g2d::Point,
		start_point:			g2d::Point,
		last_point:			g2d::Point,
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		phase:				gt::Drag_Phase,	
		button:				evt::Mousebutton,
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_mouse_drag_fn:		Mouse_Drag_Fn,
		#
		state:				Ref(p2l::Linestate),
		cursor_on:			Ref(Bool),			# Tracks whether blinking cursor is currently in/visible.
		#
		notify_statewatchers:		Void -> Void,			# 
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Drag_Fn =  Mouse_Drag_Fn_Arg -> Void;



	Mouse_Transit_Fn_Arg							# Note that buttons are always all up in a mouse-transit event -- otherwise it is a mouse-drag event.
	    =
	    MOUSE_TRANSIT_FN_ARG
	      {
		id:				iuw::Id,			# Unique id.
		doc:				String,
		event_point:			g2d::Point,
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		transit:			gt::Gadget_Transit,		# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_mouse_transit_fn:	Mouse_Transit_Fn,
		#
		state:				Ref(p2l::Linestate),
		cursor_on:			Ref(Bool),			# Tracks whether blinking cursor is currently in/visible.
		#
		notify_statewatchers:		Void -> Void,			# 
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Transit_Fn =  Mouse_Transit_Fn_Arg -> Void;



	Key_Event_Fn_Arg
	    =
	    KEY_EVENT_FN_ARG
	      {
		id:				iuw::Id,			# Unique id.
		doc:				String,
		key_event:			gt::Key_Event,			# KEY_PRESS or KEY_RELEASE
		keycode:			evt::Keycode,			# Keycode of the depressed key.
		keysym:				evt::Keysym,			# Keysym  of the depressed key.  See Note[1] in src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.api
		string:				String,				# Ascii  for the depressed key.  See Note[1] in src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.api
		char:				Char,				# First char of 'string' ('\0' if string-length != 1).
		event_point:			g2d::Point,
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_key_event_fn:		Key_Event_Fn,
		#
		state:				Ref(p2l::Linestate),
		cursor_on:			Ref(Bool),			# Tracks whether blinking cursor is currently in/visible.
		#
		notify_statewatchers:		Void -> Void,			# 
		needs_redraw_gadget_request:	Void -> Void,			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
		lineeditor_to_textpane:		l2p::Lineeditor_To_Textpane
	      }
	withtype
	Key_Event_Fn =  Key_Event_Fn_Arg -> Void;



	Option	= PIXELS_SQUARE		Int
		#
		| PIXELS_HIGH_MIN	Int
		| PIXELS_WIDE_MIN	Int
		#
		| PIXELS_HIGH_CUT	Float
		| PIXELS_WIDE_CUT	Float
		#
		| INITIALLY_ACTIVE	Bool
		#
		| BODY_COLOR				rgb::Rgb
		| BODY_COLOR_WITH_MOUSEFOCUS		rgb::Rgb
		| BODY_COLOR_WHEN_ON			rgb::Rgb
		| BODY_COLOR_WHEN_ON_WITH_MOUSEFOCUS	rgb::Rgb
		#
		| ID			iuw::Id
		| DOC			String
		#
		| STATE			p2l::Linestate				# What to display in lineeditor.
		#
		| FONT_SIZE		Int					# Show any text in this pointsize.  Default is 12.
		| FONTS			List(String)				# Override theme font:  Font to use for text label, e.g. "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*".  We'll use the first font in list which is found on X server, else "9x15" (which X guarantees to have).
		#
		| ROMAN								# Show any text in plain  font from widget-theme.  This is the default.
		| ITALIC							# Show any text in italic font from widget-theme.
		| BOLD								# Show any text in bold   font from widget-theme.  NB: Text is either bold or italic, not both.
		#
		| REDRAW_FN		Redraw_Fn				# Application-specific handler for widget redraw.
		| MOUSE_CLICK_FN	Mouse_Click_Fn				# Application-specific handler for mousebutton clicks.
		| MOUSE_DRAG_FN		Mouse_Drag_Fn				# Application-specific handler for mouse drags.
		| MOUSE_TRANSIT_FN	Mouse_Transit_Fn			# Application-specific handler for mouse crossings.
		| KEY_EVENT_FN		Key_Event_Fn				# Application-specific handler for keyboard input.
		#
		| STATEWATCHER		(p2l::Linestate -> Void)			# Widget's current state              will be sent to these fns each time state changes.
#		| PORTWATCHER		(Null_Or(Textpane_To_Lineditor) -> Void)	# Widget's app port                   will be sent to these fns at widget startup.
		| SITEWATCHER		(Null_Or((iuw::Id,g2d::Box)) -> Void)	# Widget's site in window coordinates will be sent to these fns each time it changes.
		;								# To help prevent deadlock, watcher fns should be fast and nonblocking, typically just setting a var or entering something into a mailqueue.
		
	fun process_options
	    ( options: List(Option),
	      #
	      {	body_color,
		body_color_with_mousefocus,
		body_color_when_on,
		body_color_when_on_with_mousefocus,
		#
		lineeditor_id,
		widget_doc,
		#
		state,
		#
		fonts,
		font_weight,
		font_size,
		#
		redraw_fn,
		mouse_click_fn,
		mouse_drag_fn,
		mouse_transit_fn,
		key_event_fn,
		#
		initially_active,
		#
		pixels_high_min,
		pixels_high_cut,
		widget_options,
	        #
#		portwatchers,
		statewatchers,
		sitewatchers
	      }
	    )
	    =
	    {   my_body_color				=  REF body_color;
		my_body_color_with_mousefocus		=  REF body_color_with_mousefocus;
		my_body_color_when_on			=  REF body_color_when_on;
		my_body_color_when_on_with_mousefocus	=  REF body_color_when_on_with_mousefocus;
		#
		my_lineeditor_id			=  REF  lineeditor_id;
		my_widget_doc				=  REF  widget_doc;
		#
		my_state				=  REF  state;
		#
		my_fonts				=  REF  fonts;
		my_font_weight				=  REF  font_weight;
		my_font_size				=  REF  font_size;
		#
		my_redraw_fn				=  REF  redraw_fn;
		my_mouse_click_fn			=  REF  mouse_click_fn;
		my_mouse_drag_fn			=  REF  mouse_drag_fn;
		my_mouse_transit_fn			=  REF  mouse_transit_fn;
		my_key_event_fn				=  REF  key_event_fn;
		#
		my_initially_active			=  REF  initially_active;
		#
		my_pixels_high_min			=  REF  pixels_high_min;
		my_pixels_high_cut			=  REF  pixels_high_cut;
		my_widget_options			=  REF  widget_options;
		#
#		my_portwatchers				=  REF  portwatchers;
		my_statewatchers			=  REF  statewatchers;
		my_sitewatchers				=  REF  sitewatchers;
		#

		apply  do_option  options
		where
		    fun do_option (INITIALLY_ACTIVE			b) =>   my_initially_active	:=  b;
			#
			do_option (BODY_COLOR				c) =>	my_body_color				:=  THE c;
			do_option (BODY_COLOR_WITH_MOUSEFOCUS		c) =>   my_body_color_with_mousefocus		:=  THE c;
			do_option (BODY_COLOR_WHEN_ON			c) =>	my_body_color_when_on			:=  THE c;
			do_option (BODY_COLOR_WHEN_ON_WITH_MOUSEFOCUS	c) =>	my_body_color_when_on_with_mousefocus	:=  THE c;
			#
			do_option (ID					i) =>   my_lineeditor_id	:=  THE i;
			do_option (DOC					d) =>   my_widget_doc		:=      d;
			#
			do_option (STATE				t) =>   my_state		:=  t;
			#
			do_option (FONTS				t) =>   my_fonts		:=  t;
			#
			do_option (ROMAN				 ) =>   my_font_weight		:=  THE wt::ROMAN_FONT;
			do_option (ITALIC				 ) =>   my_font_weight		:=  THE wt::ITALIC_FONT;
			do_option (BOLD					 ) =>   my_font_weight		:=  THE wt::BOLD_FONT;
			#
			do_option (FONT_SIZE				i) =>   my_font_size		:=  THE i;
			#
			do_option (REDRAW_FN				f) =>   my_redraw_fn		:=      f;
			do_option (MOUSE_CLICK_FN			f) =>   my_mouse_click_fn	:=      f;
			do_option (MOUSE_DRAG_FN			f) =>	my_mouse_drag_fn	:=  THE f;
			do_option (MOUSE_TRANSIT_FN			f) =>	my_mouse_transit_fn	:=      f;
			do_option (KEY_EVENT_FN				f) =>	my_key_event_fn		:=      f;
			#
#			do_option (PORTWATCHER				c) =>	my_portwatchers		:=  c ! *my_portwatchers;
			do_option (STATEWATCHER				c) =>	my_statewatchers	:=  c ! *my_statewatchers;
			do_option (SITEWATCHER				c) =>	my_sitewatchers		:=  c ! *my_sitewatchers;
			#
			#
			do_option (PIXELS_HIGH_MIN			i) =>   my_pixels_high_min	:=  i;
			do_option (PIXELS_WIDE_MIN			i) =>   my_widget_options	:=  (wi::PIXELS_WIDE_MIN i) ! *my_widget_options;
			#
			do_option (PIXELS_HIGH_CUT			f) =>   my_pixels_high_cut	:=  f;
			do_option (PIXELS_WIDE_CUT			f) =>   my_widget_options	:=  (wi::PIXELS_WIDE_CUT f) ! *my_widget_options;
			#
			do_option (PIXELS_SQUARE			i) =>   my_widget_options	:=  (wi::PIXELS_HIGH_MIN   i)
													!   (wi::PIXELS_WIDE_MIN   i)
													!   (wi::PIXELS_HIGH_CUT 0.0)
													!   (wi::PIXELS_WIDE_CUT 0.0)
													!   *my_widget_options;
		    end;
		end;

		{ body_color				=>  *my_body_color,
		  body_color_with_mousefocus		=>  *my_body_color_with_mousefocus,
		  body_color_when_on			=>  *my_body_color_when_on,
		  body_color_when_on_with_mousefocus	=>  *my_body_color_when_on_with_mousefocus,
		  #
		  lineeditor_id				=>  *my_lineeditor_id,
		  widget_doc				=>  *my_widget_doc,
		  #
		  state					=>  *my_state,
		  #
		  fonts					=>  *my_fonts,
		  font_weight				=>  *my_font_weight,
		  font_size				=>  *my_font_size,
		  #
		  redraw_fn				=>  *my_redraw_fn,
		  mouse_click_fn			=>  *my_mouse_click_fn,
		  mouse_drag_fn				=>  *my_mouse_drag_fn,
		  mouse_transit_fn			=>  *my_mouse_transit_fn,
		  key_event_fn				=>  *my_key_event_fn,
		  #
		  initially_active			=>  *my_initially_active,
		  #
		  pixels_high_min			=>  *my_pixels_high_min,
		  pixels_high_cut			=>  *my_pixels_high_cut,
		  widget_options			=>  *my_widget_options,
		  #
#		  portwatchers				=>  *my_portwatchers,
		  statewatchers				=>  *my_statewatchers,
		  #	
		  sitewatchers				=>  *my_sitewatchers
		};
	    };


	fun default_redraw_fn (REDRAW_FN_ARG a)							# Handle a guiboss request to redraw ourself.
	    =
	    {	font_size	=  a.font_size;
		font_weight	=  a.font_weight;
		fonts		=  a.fonts;
		gadget_mode	=  a.gadget_mode;
		palette		=  a.palette;
		site		=  a.site;
		state		=  a.state;
		theme		=  a.theme;
		cursor_on	=  a.cursor_on;

		background_box	=  site;

		fun get_fontnames ()
		    =
		    {   font_size_to_use
			    =
			    case font_size	THE i => i;
						NULL  => *theme.default_font_size;
			    esac;

			fontname_to_use
			    =
			    case font_weight  THE wt::ROMAN_FONT  =>  *theme.get_roman_fontname  font_size_to_use;
					      THE wt::ITALIC_FONT =>  *theme.get_italic_fontname font_size_to_use;
					      THE wt::BOLD_FONT   =>  *theme.get_bold_fontname   font_size_to_use;
					      NULL            =>  *theme.get_roman_fontname  font_size_to_use;
			    esac;

			fontnames =  fonts  @  [ fontname_to_use, "9x15" ];

			fontnames;
		    };


		fun get_text_dimensions (text: String)
		    =
		    {   g =  wti::get__guiboss_to_topwindow  theme;
			#
			font = g.get_font (get_fontnames ());

			{ font_ascent      =>  font.font_height.ascent,
			  font_descent     =>  font.font_height.descent,
			  length_in_pixels =>  font.string_length_in_pixels text
			};
		    };

		fun append_text_to_displaylist
		      (
			displaylist_so_far:	gd::Gui_Displaylist,
			text_indent:		Int,
			text:			String,
			text_box:		g2d::Box,
			inverse_video:		Bool
		      )
		    =
		    if (string::length text == 0)
			#
			(displaylist_so_far, text_indent);										# Nothing to do.
		    else
			text_color =  palette.text_color;
			body_color =  palette.body_color;

			my (text_color, body_color)
			    =
			    if (inverse_video)	(body_color, text_color);
			    else		(text_color, body_color);
			    fi;

			text_dimensions =  get_text_dimensions  text;

			fontnames =  get_fontnames ();

			box_corners =   g2d::box::box_corners  text_box;
			#
			(g2d::point::mean [ box_corners.upper_left, box_corners.lower_left ])
			    ->
			    { row, col };

			# Indent text a bit and also also center
			# it properly vertically -- most fonts
			# have ascent > descent:
			#
			row =  row - text_dimensions.font_descent + ((text_dimensions.font_ascent + text_dimensions.font_descent) / 2); 
			col =  col + text_indent;											# In general we're starting somewhere within the line, after other stuff has been rendered.
			draw_point = { row, col };
			#
			textbox     = { row  =>  box_corners.upper_left.row,								# Area behind text.
					col  =>  col,
					high =>  box_corners.lower_left.row - box_corners.upper_left.row,
					wide =>  text_dimensions.length_in_pixels
				      };

			displaylist = [ gd::COLOR
					  ( body_color,
					    [ gd::FILLED_BOXES [ textbox ] ]
					  ),												# Clear area behind text to correct color (which varies depending whether inverse_video is TRUE).
					#
					gd::COLOR
					  ( text_color,
					    [ gd::FONT ( fontnames,									# Draw relevant text atop it.
							 [ gd::PUT_TEXT   ( gd::TO_RIGHT_OF_POINT,
									    [ gd::TEXT (draw_point, text) ]
									  )
							 ]
						       )
					    ]
					  )
				      ];

			displaylist_so_far
			    =
			    displaylist_so_far  @  displaylist;

			( displaylist_so_far,
			  text_indent + text_dimensions.length_in_pixels
			);
		    fi;


		displaylist =  [ gd::COLOR (palette.body_color, [ gd::FILLED_BOXES [ background_box ] ] ) ];				# Interior of widget.

		text_box =    background_box;

		text_indent  = 3;													# For readability, insert some space between frame and start of text.

		my (displaylist, text_indent)
		    =
		    case (state.cursor, cursor_on)
			#
			(THE cursor_col, TRUE)												# Cursor is visible, so draw char it is on in reverse video.
			    =>														# Value of '0' means cursor in first visible column on line, over first char in state.text (if any).
			    {	textlen = string::length state.text;
				#
				my  { text_before_cursor,
				      text_under_cursor,
				      text_after_cursor
				    }
				    =
				    if (cursor_col > textlen)
					#
					{ text_before_cursor =>  state.text + (string::repeat(" ", cursor_col-textlen)),
					  text_under_cursor  =>  " ",
					  text_after_cursor  =>  ""
					};
				    else
					{ text_before_cursor =>  string::substring (state.text, 0           ,  cursor_col),
					  text_under_cursor  =>  string::substring (state.text, cursor_col  ,  1         ),
					  text_after_cursor  =>  string::extract   (state.text, cursor_col+1,  NULL      )	except INDEX_OUT_OF_BOUNDS = ""
					};
				    fi;

				my (displaylist, text_indent) =   append_text_to_displaylist (displaylist, text_indent, text_before_cursor, text_box, FALSE);
				my (displaylist, text_indent) =   append_text_to_displaylist (displaylist, text_indent, text_under_cursor,  text_box, TRUE );
				my (displaylist, text_indent) =   append_text_to_displaylist (displaylist, text_indent, text_after_cursor,  text_box, FALSE);

				(displaylist, text_indent);
			    };	

			_ =>														# Cursor NOT visible, so draw string normally.
			    {
				append_text_to_displaylist (displaylist, text_indent, state.text, text_box, FALSE);
			    };

		    esac;

		displaylist  = [ gd::CLIP_TO (text_box, displaylist) ];

		fun point_in_gadget (point: g2d::Point)
		    =
		    g2d::point::in_box (point, text_box);

		point_in_gadget = THE point_in_gadget;


		{ displaylist,
		  point_in_gadget,
		  pixels_high_min => 0,
		  pixels_wide_min => 0
		};
	    };

	fun default_mouse_click_fn
	    (
	      MOUSE_CLICK_FN_ARG
	      { id:				iuw::Id,						# Unique id.
		doc:				String,
		event:				gt::Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
		button:				evt::Mousebutton,
		point:				g2d::Point,
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,						# Widget's assigned area in window coordinates.
		modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,						# Used to call 'pass_*' methods in other imps.
		#
		default_mouse_click_fn:		Mouse_Click_Fn,
		#
		cursor_on:			Ref(Bool),						# Tracks whether blinking cursor is currently in/visible.
		state:				Ref(p2l::Linestate),
		#
		notify_statewatchers:		Void -> Void,						# 
		needs_redraw_gadget_request:	Void -> Void
	      }:				Mouse_Click_Fn_Arg
	    )
	    =
	    {
		case event
		    #
		    gt::MOUSEBUTTON_PRESS
			=>
			{   # note_state  (not button_state);
			    # needs_redraw_gadget_request ();
			};

		    gt::MOUSEBUTTON_RELEASE
			=>
			{
			    # note_state  initial_state;
			    # needs_redraw_gadget_request ();
			};
		esac;

		();
	    };

	fun default_mouse_transit_fn (MOUSE_TRANSIT_FN_ARG a)
	    =
	    case a.transit
		#
		gt::CAME =>  a.needs_redraw_gadget_request ();							# So lineeditor will lighten when mouse enters it.
		gt::LEFT =>  a.needs_redraw_gadget_request ();							# So lineeditor will revert  when mosue leaves it.
		_	 =>  ();
	    esac;


	fun default_key_event_fn (KEY_EVENT_FN_ARG a)								# Handle user keystrokes.  We just pass these to our managing Textpane instance.
	    =
	    {   lineeditor_to_textpane		=  a.lineeditor_to_textpane;
		#
		key_event_arg											# Construct a generic tpt::Key_Event_Fn arg from our lineeditor-specialized one.
		  =
		  {
		    id			=>  a.id,
		    doc			=>  a.doc,
		    key_event		=>  a.key_event,
		    keycode		=>  a.keycode,
		    keysym		=>  a.keysym,
		    string		=>  a.string,
		    char		=>  a.char,
		    event_point		=>  a.event_point,
		    widget_layout_hint	=>  a.widget_layout_hint,
		    frame_indent_hint	=>  a.frame_indent_hint,
		    site		=>  a.site,
		    modifier_keys_state	=>  a.modifier_keys_state,
		    mousebuttons_state	=>  a.mousebuttons_state,
		    widget_to_guiboss	=>  a.widget_to_guiboss,
		    theme		=>  a.theme
		  }:			    tpt::Key_Event_Fn_Arg;

		lineeditor_to_textpane.key_event_fn  key_event_arg;
	    };



	fun with
	      { paneline:	Int,
		textpane_id:	iuw::Id,
		textedit_id:	iuw::Id,
		options:	List(Option)
	      }
	    =
	    {
		#######################################
		# Top of per-imp state variable section
		#

		lineeditor_to_textpane__global	=  REF (NULL:  Null_Or(l2p::Lineeditor_To_Textpane));
		widget_to_guiboss__global	=  REF (NULL:  Null_Or( { widget_to_guiboss: gt::Widget_To_Guiboss, lineeditor_id: iuw::Id }));

		cursoronref	= REF TRUE;									# Tracks whether blinking cursor is currently in/visible.

		stateref	= REF { cursor   =>  NULL,							# Tracks location (if any) of cursor.
					selected =>  NULL,
					text	 =>  ""
				      };
		
		bogus_site
		   =
		   { col => -1,  wide => -1,
		     row => -1,  high => -1
		   }:						g2d::Box;

		last_known_site
		    =
		    REF bogus_site;

		button_active
		    =
		    REF TRUE;

		#
		#######################################



		#
	        (process_options
		  (
		    options,
		    #
		    { body_color			 =>  NULL,
		      body_color_with_mousefocus	 =>  NULL,
		      body_color_when_on		 =>  NULL,
		      body_color_when_on_with_mousefocus =>  NULL,
		      #
		      lineeditor_id	=>  NULL,
		      widget_doc	=>  "<lineeditor>",
		      #
		      state		=>  *stateref,
		      #
		      fonts		=>  [],
		      font_weight	=>  (THE wt::BOLD_FONT: Null_Or(wt::Font_Weight)),
		      font_size		=>  (NULL: Null_Or(Int)),
		      #
		      redraw_fn		=>  default_redraw_fn,
		      mouse_click_fn	=>  default_mouse_click_fn,
		      mouse_drag_fn	=>  NULL,
		      mouse_transit_fn	=>  default_mouse_transit_fn,
		      key_event_fn	=>  default_key_event_fn,
		      #
		      initially_active	=>  *button_active,
		      #
		      pixels_high_min   =>  0,									# Setting this to 16 resulted in an infinite loop of vertical site expansion in textpane.pkg.  So currently we leave the driving to textpane.pkg.
		      pixels_high_cut   =>  1.0,								# So lineeditors will evenly divide up all space left after statusline has taken its fixed allotment.
		      widget_options	=>  [],
		      #
#		      portwatchers	=>  [],
		      statewatchers	=>  [],
		      sitewatchers	=>  []
		    }
		) )
		    ->
		    {												# These values are globally visible to the subsequenc fns, which can lock them in as needed.
		      body_color,
		      body_color_with_mousefocus,
		      body_color_when_on,
		      body_color_when_on_with_mousefocus,
		      #
		      lineeditor_id,
		      widget_doc,
		      #
		      state,
		      #
		      fonts,
		      font_weight,
		      font_size,
		      #
		      redraw_fn,
		      mouse_click_fn,
		      mouse_drag_fn,
		      mouse_transit_fn,
		      key_event_fn,
		      #
		      initially_active,
		      #
		      pixels_high_min,	
		      pixels_high_cut,	
		      widget_options,
		      #
#		      portwatchers,
		      statewatchers,
		      sitewatchers
		    };

		stateref	:= state;
		button_active	:= initially_active;

		fun note_changed_gadget_activity (is_active: Bool)
		    =
		    case (*widget_to_guiboss__global)
			#
			THE { widget_to_guiboss, lineeditor_id }    =>  widget_to_guiboss.g.note_changed_gadget_activity { id => lineeditor_id, is_active };
			NULL					    =>  ();
		    esac;

		fun needs_redraw_gadget_request ()
		    =
		    case (*widget_to_guiboss__global)
			#
			THE { widget_to_guiboss, lineeditor_id }    =>  widget_to_guiboss.g.needs_redraw_gadget_request(lineeditor_id);
			NULL					    =>  ();
		    esac;



		fun note_site
		      (arg as
			{ lineeditor_id:	iuw::Id,
			  site:			g2d::Box
			}
		      )
		    =
		    if(*last_known_site != site)
			last_known_site := site;
			#
			apply tell_watcher sitewatchers
			    where
				fun tell_watcher sitewatcher
				    =
				    sitewatcher (THE (lineeditor_id,site));
			    end;
		    fi;

		fun notify_statewatchers ()
		    =	
		    apply tell_watcher statewatchers
			where
			    fun tell_watcher statewatcher
				=
				statewatcher *stateref;
			end;


		fun note_state (state: p2l::Linestate)
		    =
		    if(*stateref != state)
			#
			fun flip_blink (wa: gt::Wakeup_Arg)
			    =
			    {   cursoronref :=  not *cursoronref;
				#
				needs_redraw_gadget_request ();
			    };

			case (*widget_to_guiboss__global)						# Turn cursorblink-driving wakeme call on or off as necessary.
			    #
			    (THE { widget_to_guiboss,  lineeditor_id })
			        =>
				case ((*stateref).cursor, state.cursor)
				    #
				    (THE _, THE _) =>   ();						# Cursorblink was on,  still on,  nothing to do here.
				    (NULL , NULL ) =>   ();						# Cursorblink was off, still off, nothing to do here.

				    (THE _, NULL )							# Cursorblink was on, need to turn it off.
					=>
					widget_to_guiboss.g.wake_me
					  {
					    id	    => lineeditor_id,
					    options => [ gt::EVERY_N_FRAMES (NULL                ) ]
					  };

				    (NULL, THE _)							# Cursorblink was off, need to turn it on.
					=>
					widget_to_guiboss.g.wake_me
					  {
					    id	    => lineeditor_id,
					    options => [ gt::EVERY_N_FRAMES (THE (40, flip_blink)) ]
					  };
				esac;

			    _ => ();									# We don't expect this to happen. Should probably log an error or warning if it does...
			esac;


			stateref := state;

			needs_redraw_gadget_request ();

			notify_statewatchers ();
		    fi;

		#
		# End of state variable section
		###############################


		#####################
		# Top of port section
		#
		# Here we implement our Textpane_To_Lineditor port:

		fun set_active_to (is_active: Bool)
		    =
		    {   button_active :=  is_active;
			#
			note_changed_gadget_activity  is_active;
		    };

		fun set_state_to (state: p2l::Linestate)
		    =
		    note_state state;

		fun get_active ()
		    =
		    *button_active;

		fun get_state ()
		    =
		    *stateref;

		#
		# End of port section
		#####################


		###############################
		# Top of widget hook fn section
		#
		# These fns get called by widget_imp logic, ultimately						# widget_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		# in response to user mouseclicks and keypresses etc:

		fun startup_fn
		    { 
		      id:				iuw::Id,						# Unique id.
		      doc:				String,
		      widget_to_guiboss:		gt::Widget_To_Guiboss,
		      do:				(Void -> Void) -> Void					# Used by widget subthreads to execute code in main widget microthread.
		    }
		    =
		    {	widget_to_guiboss__global
			    :=  
			    THE { widget_to_guiboss, lineeditor_id => id };

# 			app_to_button
# 			  =
# 			  { id,
# 			    #
# 			    get_active,
# 			    get_state,
# 			    #
# 			    set_active_to,
# 			    set_state_to
# 			  }
# 			  : Textpane_To_Lineeditor
# 			  ;

			gadget_to_editboss
			    =
			    g2b::find__gadget_to_editboss  (widget_to_guiboss.g,  "lineeditor::startup_fn");

			gadget_to_editboss.note_lineeditor
			  (
			    editboss_to_lineeditor, 
			    textpane_to_lineeditor
			  )
			    where
				fun note__lineeditor_to_textpane (lineeditor_to_textpane: l2p::Lineeditor_To_Textpane)
				    =
				    {
					lineeditor_to_textpane__global := THE  lineeditor_to_textpane;
				    };

				editboss_to_lineeditor
				  =
				  { note__lineeditor_to_textpane,
				    lineeditor_id => id,
				    textpane_id,
				    textedit_id
				  }:			b2l::Editboss_To_Lineeditor;

				textpane_to_lineeditor
				  =
				  { lineeditor_id => id,
				    paneline,
				    textpane_id,
				    textedit_id,
				    #
				    get_active,
				    get_state,
				    #
				    set_active_to,
				    set_state_to
				  }:			p2l::Textpane_To_Lineeditor;
			    end;


# 			apply   tell_watcher  portwatchers							# We do this here rather than (say) above this fn because we don't want the port in circulation until we're running.
# 				where
# 				    fun tell_watcher  portwatcher
# 					=
# 					portwatcher  (THE app_to_button);
# 				end;

			();
		    };

		fun shutdown_fn ()										# Return to widget_imp an exception packaging up our state; this will be returned to guiboss_imp, saved in the
		    =												# Paused_Gui tree, and passed to our startup_fn when/if gui is restarted. This exception will never be raised;
		    {
			case *widget_to_guiboss__global
			    #
			    THE { widget_to_guiboss, lineeditor_id }
				=>
				{   gadget_to_editboss
					=
					g2b::find__gadget_to_editboss  (widget_to_guiboss.g,  "lineeditor::shutdown_fn");

				    gadget_to_editboss.drop_lineeditor { lineeditor_id, textpane_id, textedit_id };
				};

			    NULL => ();
			esac;
	
			#
# 			apply   tell_watcher  portwatchers							# 
# 				where
# 				    fun tell_watcher  portwatcher
# 					=
# 					portwatcher  NULL;
# 				end;

			apply tell_watcher sitewatchers
			    where
				fun tell_watcher sitewatcher
				    =
				    sitewatcher NULL;
			    end;
		    };
	
		fun initialize_gadget_fn
		    {
		      id:				iuw::Id,						# Unique id.
		      doc:				String,
		      site:				g2d::Box,						# Window rectangle in which to draw.
		      widget_to_guiboss:		gt::Widget_To_Guiboss,
		      theme:				wt::Widget_Theme,
		      pass_font:			List(String) -> Replyqueue
								     -> (evt::Font -> Void) -> Void,		# Nonblocking version of next, for use in imps.
		      get_font:				List(String) ->	 evt::Font,				# Accepts a list of font names which are tried in order.
		      make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		      #
		      do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
		      to:				Replyqueue						# Used to call 'pass_*' methods in other imps.
		    }
		    =
		    {	note_site  { lineeditor_id => id, site };
			#
			();
		    };

		fun redraw_request_fn_wrapper
		    {
		      id:				iuw::Id,						# Unique id.
		      doc:				String,
		      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
		      frame_indent_hint:		gt::Frame_Indent_Hint,
		      site:				g2d::Box,						# Window rectangle in which to draw.
		      popup_nesting_depth:		Int,							# 0 for gadgets on basewindow, 1 for gadgets on popup on basewindow, 2 for gadgets on popup on popup, etc.
		      #	
		      duration_in_seconds:		Float,							# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
		      widget_to_guiboss:		gt::Widget_To_Guiboss,
		      gadget_mode:			gt::Gadget_Mode,
		      #	
		      theme:				wt::Widget_Theme,
		      do:				(Void -> Void) -> Void,
		      to:				Replyqueue						# Used to call 'pass_*' methods in other imps.
		    }
		    =
		    {	note_site { lineeditor_id => id, site };
			#
			palette =   *theme.current_gadget_colors  { gadget_is_on => FALSE,			# We're not a button, we don't have ON/OFF state. (But maybe click-to-focus should work like ON, if/when we implement it?)
								    gadget_mode,
								    popup_nesting_depth,
								    #
								    body_color,
								    body_color_when_on,
								    body_color_with_mousefocus,
								    body_color_when_on_with_mousefocus
								  };

			redraw_fn_arg
			    =
			    REDRAW_FN_ARG
			      { id,
				doc,
				frame_number,
				frame_indent_hint,
				site,
				popup_nesting_depth,
				duration_in_seconds,
				widget_to_guiboss,
				gadget_mode,
				theme,
				do,
				to,
				palette,
				#
				default_redraw_fn,	
				#
				cursor_on => *cursoronref,
				state	  => *stateref,

				fonts,
				font_weight,
				font_size
			      };

			(redraw_fn  redraw_fn_arg)
			    ->
			    { displaylist,
			      point_in_gadget,
			      pixels_high_min,
			      pixels_wide_min
			    };

			widget_to_guiboss.g.redraw_gadget { id, site, displaylist, point_in_gadget };
		    };


		fun mouse_click_fn_wrapper									# This a callback we hand to   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		      {
			id:				iuw::Id,						# Unique id.
			doc:				String,
			event:				gt::Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
			button:				evt::Mousebutton,
			point:				g2d::Point,
			widget_layout_hint:		gt::Widget_Layout_Hint,
			frame_indent_hint:		gt::Frame_Indent_Hint,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			widget_to_guiboss:		gt::Widget_To_Guiboss,
			theme:				wt::Widget_Theme,
			do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
			to:				Replyqueue						# Used to call 'pass_*' methods in other imps.
		      }
		    = 
		    {	note_site  { lineeditor_id => id, site };
			#
			mouse_click_fn_arg
			    =
			    MOUSE_CLICK_FN_ARG
			      {
				id,
				doc,
				event,
				button,
				point,
				widget_layout_hint,
				frame_indent_hint,
				site,
				modifier_keys_state,
				mousebuttons_state,
				widget_to_guiboss,
				theme,
				do,
				to,
				#
				default_mouse_click_fn,
				#
				state	  =>  stateref,								# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
				cursor_on =>  cursoronref,
				#
				notify_statewatchers,
				needs_redraw_gadget_request
			      };

			mouse_click_fn  mouse_click_fn_arg;
		    };

		fun mouse_drag_fn_wrapper									# This a callback we hand to   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		    (
		      {	id:				iuw::Id,						# Unique id.
			doc:				String,
			event_point:			g2d::Point,
			start_point:			g2d::Point,
			last_point:			g2d::Point,
			widget_layout_hint:		gt::Widget_Layout_Hint,
			frame_indent_hint:		gt::Frame_Indent_Hint,
			site:				g2d::Box,						# Widget's assigned area in window coordinates.
			phase:				gt::Drag_Phase,	
			button:				evt::Mousebutton,
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			widget_to_guiboss:		gt::Widget_To_Guiboss,
			theme:				wt::Widget_Theme,
			do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
			to:				Replyqueue						# Used to call 'pass_*' methods in other imps.
		      }
		    )
		    = 
		    {	note_site  { lineeditor_id => id, site };
			#
			mouse_drag_fn_arg
			    =
			    MOUSE_DRAG_FN_ARG
			      {
				id,
				doc,
				event_point,
				start_point,
				last_point,
				widget_layout_hint,
				frame_indent_hint,
				site,
				phase,
				button,
				modifier_keys_state,
				mousebuttons_state,
				widget_to_guiboss,
				theme,
				do,
				to,
				#
				default_mouse_drag_fn =>  \\ _ = (),						# Default drag behavior for buttons is to do absolutely nothing.
				#
				state	  =>  stateref,								# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
				cursor_on =>  cursoronref,
				#
				notify_statewatchers,
				needs_redraw_gadget_request
			      };

			case mouse_drag_fn
			    #
			    THE mouse_drag_fn =>   mouse_drag_fn  mouse_drag_fn_arg;
			    NULL	      =>   ();								# We do not expect this case to happen: If mouse_drag_fn is NULL mouse_drag_fn_wrapper should not have been registered with widget-imp so we should never get called.
			esac;
		    };

		fun mouse_transit_fn_wrapper
		      #
		      ( arg as
			{
			  id:				iuw::Id,						# Unique id.
			  doc:				String,
			  event_point:			g2d::Point,
			  widget_layout_hint:		gt::Widget_Layout_Hint,
			  frame_indent_hint:		gt::Frame_Indent_Hint,
			  site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			  transit:			gt::Gadget_Transit,					# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
			  modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			  widget_to_guiboss:		gt::Widget_To_Guiboss,
			  theme:			wt::Widget_Theme,
			  do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
			  to:				Replyqueue						# Used to call 'pass_*' methods in other imps.
			}
		      )	
		    = 
		    {	note_site { lineeditor_id => id, site };
			#
			mouse_transit_fn_arg
			    =
			    MOUSE_TRANSIT_FN_ARG
			      {
				id,
				doc,
				event_point,
				widget_layout_hint,
				frame_indent_hint,
				site,
				transit,
				modifier_keys_state,
				widget_to_guiboss,
				theme,
				do,
				to,
				#
				default_mouse_transit_fn,							# 
				#
				state	  =>  stateref,								# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
				cursor_on =>  cursoronref,
				#
				notify_statewatchers,
				needs_redraw_gadget_request
			      };

			mouse_transit_fn  mouse_transit_fn_arg;

			();
		    };

		fun key_event_fn_wrapper
		      {
			id:				iuw::Id,						# Unique id.
			doc:				String,
			key_event:			gt::Key_Event,						# KEY_PRESS or KEY_RELEASE.
			keycode:			evt::Keycode,						# Keycode of the depressed key.
			keysym:				evt::Keysym,						# Keysym  of the depressed key.
			string:				String,							# Ascii  for the depressed key.
			char:				Char,							# First char of 'string' ('\0' if string-length != 1).
			event_point:			g2d::Point,
			widget_layout_hint:		gt::Widget_Layout_Hint,
			frame_indent_hint:		gt::Frame_Indent_Hint,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			widget_to_guiboss:		gt::Widget_To_Guiboss,
			theme:				wt::Widget_Theme,
			do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
			to:				Replyqueue						# Used to call 'pass_*' methods in other imps.
		      }
		    = 
		    {	note_site { lineeditor_id => id, site };
			#
			case (*lineeditor_to_textpane__global)
			    #
			    THE lineeditor_to_textpane
				=>
				{
				    key_event_fn_arg
					=
					KEY_EVENT_FN_ARG
					  {
					    id,
					    doc,
					    key_event,
					    keycode,
					    keysym,
					    string,
					    char,
					    event_point,
					    widget_layout_hint,
					    frame_indent_hint,
					    site,
					    modifier_keys_state,
					    mousebuttons_state,
					    widget_to_guiboss,
					    theme,
					    do,
					    to,
					    #
					    default_key_event_fn,
					    #
					    state	  =>  stateref,						# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
					    cursor_on =>  cursoronref,
					    #
					    notify_statewatchers,
					    needs_redraw_gadget_request,
					    lineeditor_to_textpane
					  };

				    key_event_fn  key_event_fn_arg;
				};

			    NULL => ();										# We don't expect this -- we should be fully wired well before any keystrokes have time to arrive. Possibly we should log a warning or even fatal error.
			esac;

			();
		    };


		#
		# End of widget hook fn section
		###############################

		widget_options
		    =
		    case mouse_drag_fn
			#
			THE _ =>  (wi::MOUSE_DRAG_FN mouse_drag_fn_wrapper)       ! widget_options;		# Register for drag events only if we are going to use them.
			NULL  =>					            widget_options;
		    esac;

		widget_options
		    =
		    case lineeditor_id
			#
			THE id =>  (wi::ID id)					  ! widget_options;		# 
			NULL   =>						    widget_options;
		    esac;

		widget_options
		  =
		  [ wi::STARTUP_FN			startup_fn,						# We always register for these five because our base behavior depends on them.
		    wi::SHUTDOWN_FN			shutdown_fn,
		    wi::INITIALIZE_GADGET_FN		initialize_gadget_fn,
		    wi::REDRAW_REQUEST_FN		redraw_request_fn_wrapper,
		    wi::MOUSE_CLICK_FN			mouse_click_fn_wrapper,
		    wi::MOUSE_TRANSIT_FN		mouse_transit_fn_wrapper,
		    wi::KEY_EVENT_FN			key_event_fn_wrapper,
		    wi::PIXELS_HIGH_MIN			pixels_high_min,
		    wi::PIXELS_HIGH_CUT			pixels_high_cut,
		    wi::DOC				widget_doc
		  ]
		  @
		  widget_options
		  ;

		make_widget_fn =  wi::make_widget_start_fn  widget_options;

		gt::WIDGET  make_widget_fn;									# So caller can write   guiplan = gt::ROW [ button::with [...], button::with [...], ... ];
	    };													# PUBLIC
    };
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
