## editboss-imp.pkg
#
# See overview comments in:
#
#     src/lib/x-kit/widget/edit/editboss-imp.api

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package iuw =  issue_unique_widget_id;			# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg

    package g2b =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/edit/gadget-to-editboss.pkg
    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss		is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package e2t =  editboss_to_textbuffer;			# editboss_to_textbuffer	is from   src/lib/x-kit/widget/edit/editboss-to-textbuffer.pkg
    package t2e =  textbuffer_to_editboss;			# textbuffer_to_editboss	is from   src/lib/x-kit/widget/edit/textbuffer-to-editboss.pkg

    package tbi =  textbuffer_imp;				# textbuffer_imp		is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg
    package t2t =  textpane_to_textbuffer;			# textpane_to_textbuffer	is from   src/lib/x-kit/widget/edit/textpane-to-textbuffer.pkg

    package e2m =  textedit_to_minibuffer;			# textedit_to_minibuffer	is from   src/lib/x-kit/widget/edit/textedit-to-minibuffer.pkg
    package p2s =  textpane_to_statusline;			# textpane_to_statusline	is from   src/lib/x-kit/widget/edit/textpane-to-statusline.pkg
    package p2l =  textpane_to_lineeditor;			# textpane_to_lineeditor	is from   src/lib/x-kit/widget/edit/textpane-to-lineeditor.pkg

    package e2p =  textedit_to_textpane;			# textedit_to_textpane		is from   src/lib/x-kit/widget/edit/textedit-to-textpane.pkg
    package p2e =  textpane_to_textedit;			# textpane_to_textedit		is from   src/lib/x-kit/widget/edit/textpane-to-textedit.pkg
    package m2e =  minibuffer_to_textedit;			# minibuffer_to_textedit	is from   src/lib/x-kit/widget/edit/minibuffer-to-textedit.pkg
    package s2p =  statusline_to_textpane;			# statusline_to_textpane	is from   src/lib/x-kit/widget/edit/statusline-to-textpane.pkg
    package l2p =  lineeditor_to_textpane;			# lineeditor_to_textpane	is from   src/lib/x-kit/widget/edit/lineeditor-to-textpane.pkg

    package b2m =  editboss_to_minibuffer;			# editboss_to_minibuffer	is from   src/lib/x-kit/widget/edit/editboss-to-minibuffer.pkg
    package b2s =  editboss_to_statusline;			# editboss_to_statusline	is from   src/lib/x-kit/widget/edit/editboss-to-statusline.pkg
    package b2l =  editboss_to_lineeditor;			# editboss_to_lineeditor	is from   src/lib/x-kit/widget/edit/editboss-to-lineeditor.pkg
    #
    package b2e =  editboss_to_textedit;			# editboss_to_textedit		is from   src/lib/x-kit/widget/edit/editboss-to-textedit.pkg
    package b2p =  editboss_to_textpane;			# editboss_to_textpane		is from   src/lib/x-kit/widget/edit/editboss-to-textpane.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

Dummy1 = tbi::Textbuffer_Egg;	 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy2 = b2m::Editboss_To_Minibuffer; 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy3 = b2s::Editboss_To_Statusline; 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy4 = b2l::Editboss_To_Lineeditor; 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy5 = b2e::Editboss_To_Textedit; 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy6 = b2p::Editboss_To_Textpane; 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package editboss_imp
    :       Editboss_Imp												# Editboss_Imp		is from   src/lib/x-kit/widget/edit/editboss-imp.api
    {
	Editboss_Option
	  #
	  =  MICROTHREAD_NAME	String											# 
	  |  ID			Id											# Stable, unique id for imp.
	  ;	

	Editboss_Arg =  List(Editboss_Option);										# Currently no required component.

	Imports = {													# Ports we use, provided by other imps.
		    editboss_to_guiboss:	e2g::Editboss_To_Guiboss
		  };


	Textbuffer_Info
	  =
	  { id:					Id,
	    #
	    editboss_to_textbuffer:		e2t::Editboss_To_Textbuffer,
	    textpane_to_textbuffer:		t2t::Textpane_To_Textbuffer,
	    #
	    buffername:				Ref(String),
	    end_gun':				End_Gun
	  };


	Lineeditor_Info
	  =
	  { textpane_to_lineeditor:		p2l::Textpane_To_Lineeditor,
	    editboss_to_lineeditor:		b2l::Editboss_To_Lineeditor
	  };

	Textpane_Info
	  =
	  { textpane_id:			iuw::Id,
	    textedit_id:			iuw::Id,
	    #
	      editboss_to_textpane:		Ref( Null_Or(   b2p::Editboss_To_Textpane ) ),
	      textedit_to_textpane:		Ref( Null_Or(   e2p::Textedit_To_Textpane ) ),
	    statusline_to_textpane:		Ref( Null_Or( s2p::Statusline_To_Textpane ) ),
	    lineeditor_to_textpane:		Ref( Null_Or( l2p::Lineeditor_To_Textpane ) ),
	    #
	    textpane_to_textedit:		Ref( Null_Or( p2e::Textpane_To_Textedit   ) ),
	    textpane_to_statusline:		Ref( Null_Or( p2s::Textpane_To_Statusline ) ),
	    editboss_to_statusline: 		Ref( Null_Or( b2s::Editboss_To_Statusline ) ),
	    #
	    lineeditors:			Ref( im::Map( Lineeditor_Info		  ) )
	  };
 
	Textedit_Info
	  =
	  { textedit_id:			iuw::Id,
	    #
	    editboss_to_textedit:		Ref( Null_Or( b2e::Editboss_To_Textedit   ) ),
	    textpane_to_textedit:		Ref( Null_Or( p2e::Textpane_To_Textedit   ) ),
	    minibuffer_to_textedit:		Ref( Null_Or( m2e::Minibuffer_To_Textedit ) ),
	    #
	    textedit_to_minibuffer:		Ref( Null_Or( e2m::Textedit_To_Minibuffer ) ),
	    editboss_to_minibuffer: 		Ref( Null_Or( b2m::Editboss_To_Minibuffer ) ),
	    #
	    textpanes:				Ref( im::Map( Textpane_Info ) )
	  };
	

	Editboss_State													# Holds all nonephemeral mutable state maintained by package.
	  =
	  {
	    textbuffers_by_name:		Ref( sm::Map( Textbuffer_Info ) ),					# All currently active textbuffers, by name.
	    textbuffers_by_id:			Ref( im::Map( Textbuffer_Info ) ),					# All currently active textbuffers, by id.
	    textedits_by_id:			Ref( im::Map( Textedit_Info   ) )					# All currently active textedits,   by id.
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Editboss_State,
			      editboss_arg:	Editboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    gadget_to_editboss:		Crypt									# The Crypt encapsulates type gadget_to_editboss::Gadget_To_Editboss. (We don't want to drag that typecomplex into guiboss.)
		  };


	Editboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Editboss_State,								# State which is preserved across imp shutdown/restart cycles.
			editboss_arg:		Editboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			id:			Id
		      };

	Editboss_Q    = Mailqueue( Runstate -> Void );




	fun run ( editboss_q:			Editboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Editboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    editboss_arg:		Editboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# 
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                        ==>  shut_down_editboss_imp',
			    take_from_mailqueue' editboss_q ==>  do_editboss_plea
			];

			loop ();
		    }	
		    where
			fun do_editboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_editboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	



	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()				# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		gadget_to_editboss
		  =
		  { id,
		    get_or_make_textbuffer,
		    #
		    note_minibuffer,
		    note_statusline,
		    note_lineeditor,
		    note_textpane,
		    note_textedit,
		    #
		    drop_minibuffer,
		    drop_statusline,
		    drop_lineeditor,
		    drop_textpane,
		    drop_textedit
		  };

		exports	    = { gadget_to_editboss => crypt }
				where
				    crypt = { key => "gadget_to_editboss::GADGET_TO_EDITBOSS",
					      doc => "src/lib/x-kit/widget/edit/gadget-to-editboss.pkg",
					      val =>  g2b::GADGET_TO_EDITBOSS  gadget_to_editboss
					    };	
				end;

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, exports));							# Return value from editboss_egg'().

		(take_from_mailslot  me_slot)										# Imports from editboss_egg'().
		    ->
		    { me, editboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run ( editboss_q,		 									# Will not return.
		      { me,
			editboss_arg,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		editboss_q     =  make_mailqueue (get_current_microthread()):  Editboss_Q;


		textbuffer_to_editboss
		  =
		  { editboss_id => id
		  };


		fun note_textbuffer_statechange (statechange: t2t::Textbuffer_Statechange)
		    =
		    case statechange
			#
			t2t::BUFFERNAME (id, { was: String, now: String })
			    =>
			    put_in_mailqueue  (editboss_q,
				#
				\\ ({ me, ... }: Runstate)
				    =
				    case (im::get  (*me.textbuffers_by_id,  id_to_int id))
					#
					THE textbuffer_info
					    =>
					    {	textbuffer_info.buffername := now;							# Remember new name of textbuffer.
						me.textbuffers_by_name     := sm::drop (*me.textbuffers_by_name, was);			# Forget   old name of textbuffer.
						me.textbuffers_by_name     := sm::set  (*me.textbuffers_by_name, now, textbuffer_info);	# Remember textbuffer under its new buffername.
					    };
					#
					NULL =>
					    {   msg =  sprintf "BUFFERNAME.id (%d) not in *me.textbuffers_by_id!" (id_to_int id);
						log::fatal msg;
						raise exception FAIL msg;
					    };
				    esac
			    );	


			t2t::TEXTSTATE _ =>  ();											# List rest explicitly so as to draw a compile error if a new one gets added without us being updated.
			t2t::UNDO      _ =>  ();
			t2t::FILENAME  _ =>  ();
		    esac;

		#################################################################################
		# guiboss interface fns::
		#
		#

		fun get_or_make_textedit_info
		      {
			me:		Editboss_State,
			textedit_id:	iuw::Id
		      }:		Textedit_Info
		    =
		    case (im::get  (*me.textedits_by_id,  iuw::id_to_int textedit_id))
			#
			THE textedit_info
			    =>
			    textedit_info;
			#
			NULL =>
			    {   textedit_info =   { textedit_id,
						    #
						    editboss_to_textedit   => REF NULL,
						    textpane_to_textedit   => REF NULL,
						    minibuffer_to_textedit => REF NULL,
						    #
						    textedit_to_minibuffer => REF NULL,
						    editboss_to_minibuffer => REF NULL,
						    textpanes		   => REF im::empty
						  };

				me.textedits_by_id
				    :=
				    im::set (*me.textedits_by_id,  iuw::id_to_int textedit_id, textedit_info);

				textedit_info;
			    };
		    esac;


		fun drop_textedit_if_empty
		      {
			me:		Editboss_State,
			textedit_id:	iuw::Id
		      }
		    =
		    {   key = 	iuw::id_to_int  textedit_id;
			#
			case (im::get (*me.textedits_by_id, key))
			    #
			    THE textedit_info
				=>
				{   textedit_info
					->
					{ textedit_id,
					  #
					  editboss_to_textedit,
					  textpane_to_textedit,
					  minibuffer_to_textedit,
					  #
					  textedit_to_minibuffer,
					  editboss_to_minibuffer,
					  textpanes
					};

				    case (*editboss_to_textedit,
					  *textpane_to_textedit,
					  *minibuffer_to_textedit,
					  *textedit_to_minibuffer,
					  *editboss_to_minibuffer)
					#
					(NULL, NULL, NULL, NULL, NULL)
					    =>
					    if (im::is_empty *textpanes)
						#	
						me.textedits_by_id
						    :=
						    im::drop (*me.textedits_by_id, key);
					    fi;

					_ => ();
				    esac;
				};

			    NULL => ();
			esac;
		    };


		fun get_or_make_textpane_info
		      {
			me:		Editboss_State,
			textedit_id:	iuw::Id,
			textpane_id:	iuw::Id
		      }:		Textpane_Info
		    =
		    {   textedit_info
			    =
			    get_or_make_textedit_info { me, textedit_id };

			case (im::get  (*textedit_info.textpanes,  iuw::id_to_int textpane_id))
			    #
			    THE textpane_info
				=>
				textpane_info;
			    #
			    NULL =>
				{   textpane_info =   { textedit_id,
							textpane_id,
							#
							  editboss_to_textpane  => REF NULL,
							  textedit_to_textpane  => REF NULL,
							statusline_to_textpane  => REF NULL,
							lineeditor_to_textpane  => REF NULL,
							#
							textpane_to_textedit	=> REF NULL,
							textpane_to_statusline  => REF NULL,
							editboss_to_statusline	=> REF NULL,
							#
							lineeditors		=> REF im::empty
						      };

				    textedit_info.textpanes
					:=
					im::set (*textedit_info.textpanes,  iuw::id_to_int textpane_id, textpane_info);

				    textpane_info;
				};
			esac;
		    };


		fun drop_textpane_if_empty
		      {
			me:		Editboss_State,
			textpane_id:	iuw::Id,
			textedit_id:	iuw::Id
		      }
		    =
		    {   textpane_info =  get_or_make_textpane_info { me, textedit_id, textpane_id };
			#
			textpane_info
			  ->
			  { textpane_id:			iuw::Id,
			    textedit_id:			iuw::Id,
			    #
			      editboss_to_textpane:		Ref( Null_Or(   b2p::Editboss_To_Textpane ) ),
			      textedit_to_textpane:		Ref( Null_Or(   e2p::Textedit_To_Textpane ) ),
			    statusline_to_textpane:		Ref( Null_Or( s2p::Statusline_To_Textpane ) ),
			    lineeditor_to_textpane:		Ref( Null_Or( l2p::Lineeditor_To_Textpane ) ),
			    #
			    textpane_to_textedit:		Ref( Null_Or( p2e::Textpane_To_Textedit   ) ),
			    textpane_to_statusline:		Ref( Null_Or( p2s::Textpane_To_Statusline ) ),
			    editboss_to_statusline: 		Ref( Null_Or( b2s::Editboss_To_Statusline ) ),
			    #
			    lineeditors:			Ref( im::Map( Lineeditor_Info		  ) )
			  };

			case (  *editboss_to_textpane,
				*textedit_to_textpane,
			      *statusline_to_textpane,
			      *lineeditor_to_textpane,
			      *textpane_to_textedit,
			      *textpane_to_statusline,
			      *editboss_to_statusline)
			    #
			    (NULL, NULL, NULL, NULL, NULL, NULL, NULL)
				=>
				if (im::is_empty *lineeditors)
				    #	
				    textedit_info =  get_or_make_textedit_info { me, textedit_id };
			
				    textedit_info.textpanes
					:=
					im::drop  (*textedit_info.textpanes,  iuw::id_to_int textpane_id);
				fi;

			    _ => ();
			esac;
		    };


		fun note_minibuffer
		      (
			editboss_to_minibuffer: 	b2m::Editboss_To_Minibuffer,
			textedit_to_minibuffer:		e2m::Textedit_To_Minibuffer
		      )
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textedit_info
				    =
				    get_or_make_textedit_info  { me,  textedit_id => textedit_to_minibuffer.textedit_id };

				textedit_info.textedit_to_minibuffer :=  THE textedit_to_minibuffer;
				textedit_info.editboss_to_minibuffer :=  THE editboss_to_minibuffer;


				case (*textedit_info.minibuffer_to_textedit)
				    #
				    THE minibuffer_to_textedit
					=>
					editboss_to_minibuffer.note__minibuffer_to_textedit  minibuffer_to_textedit;
				    #
				    NULL => ();										# Haven't seen the textedit.pkg instance yet, so we'll do above in note_textedit.
				esac;


				case (*textedit_info.editboss_to_textedit)
				    #
				    THE editboss_to_textedit
					=>
					editboss_to_textedit.note__textedit_to_minibuffer  textedit_to_minibuffer;
				    #
				    NULL => ();										# Haven't seen the textedit.pkg instance yet, so we'll do above in note_textedit.
				esac;
			    }
		    );

		fun drop_minibuffer
		      {
			minibuffer_id:		iuw::Id,
			textedit_id:		iuw::Id
		      }
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textedit_info
				    =
				    get_or_make_textedit_info  { me,  textedit_id };

				textedit_info.textedit_to_minibuffer :=  NULL;
				textedit_info.editboss_to_minibuffer :=  NULL;

				# Should we be notifying textedit?  Currently presuming that they die together.
			    }
		    );


		fun note_statusline
		      (
			editboss_to_statusline:	b2s::Editboss_To_Statusline,
			textpane_to_statusline:	p2s::Textpane_To_Statusline
		      )
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   r = textpane_to_statusline;								# For brevity.
				#
				textedit_id   = r.textedit_id;
				textpane_id   = r.textpane_id;
				statusline_id = r.statusline_id;

				textpane_info
				    =
				    get_or_make_textpane_info { me, textpane_id, textedit_id };

				textpane_info.textpane_to_statusline :=  THE  textpane_to_statusline;
				textpane_info.editboss_to_statusline :=  THE  editboss_to_statusline;


				case (*textpane_info.statusline_to_textpane)
				    #
				    THE statusline_to_textpane
					=>
					editboss_to_statusline.note__statusline_to_textpane  statusline_to_textpane;
				    #
				    NULL => ();										# Haven't seen the textpane.pkg instance yet, so we'll do above in note_textpane.
				esac;


				case (*textpane_info.editboss_to_textpane)
				    #
				    THE editboss_to_textpane
					=>
					editboss_to_textpane.note__textpane_to_statusline  textpane_to_statusline;
				    #
				    NULL => ();										# Haven't seen the textpane.pkg instance yet, so we'll do above in note_textpane.
				esac;
			    }
		    );

		fun drop_statusline
		      {
			statusline_id:		iuw::Id,
			textedit_id:		iuw::Id,
			textpane_id:		iuw::Id
		      }
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textpane_info
				    =
				    get_or_make_textpane_info { me, textpane_id, textedit_id };

				textpane_info.textpane_to_statusline :=  NULL;
				textpane_info.editboss_to_statusline :=  NULL;

				# Should we notify textpane?  Currently assuming they die together.

				drop_textpane_if_empty { me, textpane_id, textedit_id };
			    }
		    );

		fun note_lineeditor
		      (
			editboss_to_lineeditor:		b2l::Editboss_To_Lineeditor,
			textpane_to_lineeditor:		p2l::Textpane_To_Lineeditor
		      )
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   r = textpane_to_lineeditor;								# For brevity.
				#
				textedit_id   = r.textedit_id;
				textpane_id   = r.textpane_id;
				lineeditor_id = r.lineeditor_id;

				textpane_info
				    =
				    get_or_make_textpane_info { me, textpane_id, textedit_id };

				lineeditor_info
				    =
				    { editboss_to_lineeditor, textpane_to_lineeditor };

				textpane_info.lineeditors
				    :=
				    im::set (  *textpane_info.lineeditors,
						iuw::id_to_int lineeditor_id,
						lineeditor_info
					    );


				case (*textpane_info.lineeditor_to_textpane)
				    #
				    THE lineeditor_to_textpane
					=>
					editboss_to_lineeditor.note__lineeditor_to_textpane  lineeditor_to_textpane;
				    #
				    NULL => ();										# Haven't seen the textpane.pkg instance yet, so we'll do above in note_textpane.
				esac;


				case (*textpane_info.editboss_to_textpane)
				    #
				    THE editboss_to_textpane
					=>
					editboss_to_textpane.note__textpane_to_lineeditor  textpane_to_lineeditor;
				    #
				    NULL => ();										# Haven't seen the textpane.pkg instance yet, so we'll do above in note_textpane.
				esac;
			    }
		    );

		fun drop_lineeditor
		      {
			lineeditor_id:		iuw::Id,
			textedit_id:		iuw::Id,
			textpane_id:		iuw::Id
		      }

		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textpane_info
				    =
				    get_or_make_textpane_info { me, textpane_id, textedit_id };

				textpane_info.lineeditors
				    :=
				    im::drop(  *textpane_info.lineeditors,
						iuw::id_to_int lineeditor_id
					    );

				# Should we notify textpane?  Currently presuming it initiated things, hence already knows.

				drop_textpane_if_empty { me, textpane_id, textedit_id };
			    }
		    );

		fun note_textpane
		      (
			editboss_to_textpane:			b2p::Editboss_To_Textpane,
			textedit_to_textpane:			e2p::Textedit_To_Textpane,
			statusline_to_textpane:			s2p::Statusline_To_Textpane,
			lineeditor_to_textpane:			l2p::Lineeditor_To_Textpane
		      )
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textpane_info
				    =
				    get_or_make_textpane_info
				      {
					me,
					textpane_id =>  textedit_to_textpane.textpane_id,
					textedit_id =>  textedit_to_textpane.textedit_id
				      };

				textpane_info.editboss_to_textpane   :=  THE   editboss_to_textpane;
				textpane_info.textedit_to_textpane   :=  THE   textedit_to_textpane;
				textpane_info.statusline_to_textpane :=  THE statusline_to_textpane;
				textpane_info.lineeditor_to_textpane :=  THE lineeditor_to_textpane;


				case (*textpane_info.textpane_to_textedit)
				    #
				    THE textpane_to_textedit
					=>
					editboss_to_textpane.note__textpane_to_textedit  textpane_to_textedit;
				    #
				    NULL => ();										# Haven't seen the textedit.pkg instance yet, so we'll do above in note_textedit.
				esac;


				case (*textpane_info.textpane_to_statusline)
				    #
				    THE textpane_to_statusline
					=>
					editboss_to_textpane.note__textpane_to_statusline  textpane_to_statusline;
				    #
				    NULL => ();										# Haven't seen the statusline.pkg instance yet, so we'll do above in note_statusline.
				esac;


				case (*textpane_info.editboss_to_statusline)
				    #
				    THE editboss_to_statusline
					=>
					editboss_to_statusline.note__statusline_to_textpane  statusline_to_textpane;
				    #
				    NULL => ();										# Haven't seen the statusline.pkg instance yet, so we'll do above in note_statusline.
				esac;


				apply	do_lineeditor
					#
					(im::vals_list  *textpane_info.lineeditors)
					where
					    fun do_lineeditor (l: Lineeditor_Info)
						=
						{   l ->  { textpane_to_lineeditor:		p2l::Textpane_To_Lineeditor,
							    editboss_to_lineeditor:		b2l::Editboss_To_Lineeditor
							  };

						    editboss_to_textpane.note__textpane_to_lineeditor    textpane_to_lineeditor;

						    editboss_to_lineeditor.note__lineeditor_to_textpane  lineeditor_to_textpane;
						};
					end;


				textedit_info
				    =
				    get_or_make_textedit_info  { me,  textedit_id => textedit_to_textpane.textedit_id };


				case (*textedit_info.editboss_to_textedit)
				    #
				    THE editboss_to_textedit
					=>
					editboss_to_textedit.note__textedit_to_textpane  textedit_to_textpane;

				    NULL => ();										# Haven't seen the textedit.pkg instance yet, so we'll do above in note_textedit.
				esac;
			    }
		    );

		fun drop_textpane
		      {
			textpane_id:		iuw::Id,
	    		textedit_id:		iuw::Id
		      }
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textpane_info
				    =
				    get_or_make_textpane_info
				      {
					me,
					textpane_id,
					textedit_id
				      };

				textpane_info.editboss_to_textpane   :=  NULL;
				textpane_info.textedit_to_textpane   :=  NULL;
				textpane_info.statusline_to_textpane :=  NULL;
				textpane_info.lineeditor_to_textpane :=  NULL;

				# Should we be notifying textedit?  Currently presuming that is not needed.
				# XXX SUCKO FIXME These drop_* fns will collectively leak memory by never removing empty Textpane_Info and Textedit_Info nodes. Ignoring that for now; possibly we'll eventually want to do periodic cleanup passes or some such.

				drop_textedit_if_empty { me, textedit_id };
			    }
		    );

		fun note_textedit
		      (
			editboss_to_textedit:			b2e::Editboss_To_Textedit,
			textpane_to_textedit:			p2e::Textpane_To_Textedit,
			minibuffer_to_textedit:			m2e::Minibuffer_To_Textedit
		      )
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textedit_info
				    =
				    get_or_make_textedit_info  { me,  textedit_id => textpane_to_textedit.textedit_id };

				
				textedit_info.editboss_to_textedit    :=  THE   editboss_to_textedit;
				textedit_info.textpane_to_textedit    :=  THE   textpane_to_textedit;
				textedit_info.minibuffer_to_textedit  :=  THE minibuffer_to_textedit;


				case (*textedit_info.textedit_to_minibuffer)
				    #
				    THE textedit_to_minibuffer
					=>
					editboss_to_textedit.note__textedit_to_minibuffer  textedit_to_minibuffer;
				    #
				    NULL => ();										# Haven't seen the minibuffer.pkg instance yet, so we'll do above in note_minibuffer.
				esac;


				case (*textedit_info.editboss_to_minibuffer)
				    #
				    THE editboss_to_minibuffer
					=>
					editboss_to_minibuffer.note__minibuffer_to_textedit  minibuffer_to_textedit;
				    #
				    NULL => ();										# Haven't seen the minibuffer.pkg instance yet, so we'll do above in note_minibuffer.
				esac;


				apply	do_textpane  (im::vals_list  *textedit_info.textpanes)
				    where
					fun do_textpane (textpane_info: Textpane_Info)
					    =
					    {
						case (*textpane_info.textedit_to_textpane)
						    #
						    THE textedit_to_textpane
							=>
							editboss_to_textedit.note__textedit_to_textpane  textedit_to_textpane;
						    #
						    NULL => ();								# Haven't seen the textpane.pkg instance yet, so we'll do above in note_textpane.
						esac;

						case (*textpane_info.editboss_to_textpane)
						    #
						    THE editboss_to_textpane
							=>
							editboss_to_textpane.note__textpane_to_textedit  textpane_to_textedit;
						    #
						    NULL => ();								# Haven't seen the textpane.pkg instance yet, so we'll do above in note_textpane.
						esac;
					    };
				    end;
			    }
		    );



		fun drop_textedit
		      {
	    		textedit_id:		iuw::Id
		      }
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ ({ id, me, ... }: Runstate)
			    =
			    {   textedit_info
				    =
				    get_or_make_textedit_info  { me,  textedit_id };
				
				textedit_info.editboss_to_textedit    :=  NULL;
				textedit_info.textpane_to_textedit    :=  NULL;
				textedit_info.minibuffer_to_textedit  :=  NULL;

				drop_textedit_if_empty { me, textedit_id };
			    }
		    );


		fun get_or_make_textbuffer
		      (
			textbuffer_arg
			as
			( buffername:	String,
			  options:	List(t2t::Textbuffer_Option)
			):		t2t::Textbuffer_Arg
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( t2t::Textpane_To_Textbuffer );
			#
			put_in_mailqueue  (editboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				case (sm::get (*me.textbuffers_by_name, buffername))
				    #
				    THE textbuffer_info
					=> 
					put_in_oneshot (reply_oneshot, textbuffer_info.textpane_to_textbuffer);
				    #
				    NULL =>
					{   egg =  tbi::make_textbuffer_egg  textbuffer_arg;
					    #
					    (egg ())
						->
						( textbuffer_exports:	tbi::Exports,
						  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
						);

					    textbuffer_imports
					      =
					      { textbuffer_to_editboss };

					    (make_run_gun ()) ->   { run_gun', fire_run_gun };
					    (make_end_gun ()) ->   { end_gun', fire_end_gun };

					    egg' (textbuffer_imports, run_gun', end_gun');

					    fire_run_gun ();

					    textbuffer_exports -> { editboss_to_textbuffer, textpane_to_textbuffer };

					    textbuffer_info = { id         =>  textpane_to_textbuffer.id,
								buffername =>  REF buffername,
								#
								editboss_to_textbuffer,
								textpane_to_textbuffer,
								end_gun'
							      };

					    me.textbuffers_by_name := sm::set (*me.textbuffers_by_name, buffername,                    textbuffer_info);
					    me.textbuffers_by_id   := im::set (*me.textbuffers_by_id,   id_to_int textbuffer_info.id,  textbuffer_info);

					    textpane_to_textbuffer.note_statewatcher (id, note_textbuffer_statechange);

					    put_in_oneshot (reply_oneshot, textpane_to_textbuffer);
					};
				esac
			);

			get_from_oneshot  reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Editboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_editboss_egg																# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	      (editboss_arg:		Editboss_Arg)													# Called (only) by startup()	in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    =
	    {	editboss_arg ->  (editboss_options);													# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( editboss_options,
		    { name		=> "editboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, editboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();														# Allocate unique imp id.
			(id, ID id ! editboss_options);													# Make our id stable across stop/restart cycles.
		    else
			(id, editboss_options);
		    fi;

		editboss_arg = (editboss_options);													# Currently no guiboss_needs component, so this is a no-op.

		me =  {
			textbuffers_by_name =>  REF sm::empty,												# All currently active textbuffers, by name.
			textbuffers_by_id   =>  REF im::empty,												# All currently active textbuffers, by id.
			#
			textedits_by_id	    =>	REF im::empty												# All currently active textedits,   by id.
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );						# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));									# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3															# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, editboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
