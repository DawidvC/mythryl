## texteditor.pkg
#
# Create the imp network constituting our emacs-flavored
# text editing infrastructure.
#
# See also:
#     src/lib/x-kit/widget/edit/textedit.pkg
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/lineeditor.pkg
#     src/lib/x-kit/widget/edit/statusline.pkg
#     src/lib/x-kit/widget/edit/minibuffer.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib





# This package gets used in:
#
#     

stipulate
    include package   threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    include package   geometry2d;						# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    #
    package chr =  char;							# char				is from   src/lib/std/src/char.pkg
    package evt =  gui_event_types;						# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package g2p =  gadget_to_pixmap;						# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package gd  =  gui_displaylist;						# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gt  =  guiboss_types;						# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package wt  =  widget_theme;						# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
    package wti =  widget_theme_imp;						# widget_theme_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/widget-theme-imp.pkg
    package r8  =  rgb8;							# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;								# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package wi  =  widget_imp;							# widget_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
    package g2d =  geometry2d;							# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;						# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg
    package mtx =  rw_matrix;							# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package pp  =  standard_prettyprint_mill;					# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package gtg =  guiboss_to_guishim;						# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg
    package le  =  lineeditor;							# lineeditor			is from   src/lib/x-kit/widget/edit/lineeditor.pkg
    package sl  =  statusline;							# statusline			is from   src/lib/x-kit/widget/edit/statusline.pkg
    package mb  =  minibuffer;							# minbuffer			is from   src/lib/x-kit/widget/edit/minibuffer.pkg
    package te  =  textedit;							# textedit			is from   src/lib/x-kit/widget/edit/texteditor.pkg
    package tp  =  textpane;							# textpane			is from   src/lib/x-kit/widget/edit/textpane.pkg
    package frm =  frame;							# frame				is from   src/lib/x-kit/widget/leaf/frame.pkg

    package iuw =  issue_unique_widget_id;					# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg

    nb =  log::note_on_stderr;							# log				is from   src/lib/std/src/log.pkg

Dummy1 =  le::Option;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy2 =  sl::Option;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy3 =  mb::Option;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy4 =  te::Option;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy5 =  tp::Option;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.

herein

    package texteditor
    :	    Texteditor								# Texteditor			is from   src/lib/x-kit/widget/edit/texteditor.api
    {
	Option	= ID			iuw::Id
		#
		| ASCII			String					# Text to draw inside button.  Default is "".
# TBD		| UTF8			String					# Text to draw inside button.  Default is "".
# TBD		| HTML			String					# Text to draw inside button.  Default is "".
		#
		| FONT_SIZE		Int					# Show any text in this pointsize.  Default is 12.
		| FONTS			List(String)				# Override theme font:  Font to use for text label, e.g. "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*".  We'll use the first font in list which is found on X server, else "9x15" (which X guarantees to have).
		#
		| ROMAN								# Show any text in plain  font from widget-theme.  This is the default.
		| ITALIC							# Show any text in italic font from widget-theme.
		| BOLD								# Show any text in bold   font from widget-theme.  NB: Text is either bold or italic, not both.
		;
		
	fun process_options
	    ( options: List(Option),
	      #
	      {	widget_id,
		#
		ascii,
		#
		fonts,
		font_weight,
		font_size
	      }
	    )
	    =
	    {   my_widget_id				=  REF  widget_id;
		#
		my_ascii				=  REF  ascii;
		#
		my_fonts				=  REF  fonts;
		my_font_weight				=  REF  font_weight;
		my_font_size				=  REF  font_size;
		#

		apply  do_option  options
		where
		    fun do_option (ID					i) =>   my_widget_id		:=  THE i;
			#
			do_option (ASCII				t) =>   my_ascii		:=  t;
			#
			do_option (FONTS				t) =>   my_fonts		:=  t;
			#
			do_option (ROMAN				 ) =>   my_font_weight		:=  THE wt::ROMAN_FONT;
			do_option (ITALIC				 ) =>   my_font_weight		:=  THE wt::ITALIC_FONT;
			do_option (BOLD					 ) =>   my_font_weight		:=  THE wt::BOLD_FONT;
			#
			do_option (FONT_SIZE				i) =>   my_font_size		:=  THE i;
			#
		    end;
		end;

		{ widget_id				=>  *my_widget_id,
		  #
		  ascii					=>  *my_ascii,
		  #
		  fonts					=>  *my_fonts,
		  font_weight				=>  *my_font_weight,
		  font_size				=>  *my_font_size
		};
	    };


	fun with  ( buffername:		String,								# PUBLIC
		    options:		List(Option)
		  )	
	    =
	    {
	        (process_options
		  (
		    options,
		    #
		    { widget_id		=>  NULL,
		      #	
		      ascii		=>  "",
		      #
		      fonts		=>  [],
		      font_weight	=>  (THE wt::BOLD_FONT: Null_Or(wt::Font_Weight)),
		      font_size		=>  (NULL: Null_Or(Int))
		    }
		) )
		    ->
		    {												# These values are globally visible to the subsequenc fns, which can lock them in as needed.
		      widget_id,
		      #	
		      ascii,
		      #
		      fonts,
		      font_weight,
		      font_size
		    };

		#
		#######################################
		# Top of per-imp state variable section
		#


		textpanes_mark	 =  issue_unique_id ();
		lineeditors_mark =  issue_unique_id ();

		textpane_id	 =  iuw::issue_unique_id ();
		textedit_id	 =  iuw::issue_unique_id ();

		gt::FRAME
		  ( [gt::FRAME_WIDGET (textedit::with { textedit_id, options => [] }) ],
		    gt::COL
		      [	
			gt::MARK'
			  ( textpanes_mark,
			    "textpanes",
			    gt::FRAME
			      ( [ gt::FRAME_WIDGET (textpane::with { textedit_id, textpane_id, lineeditors_mark, options => [ tp::ASCII ascii ] }) ],
				gt::COL
				  [
				    gt::MARK'
				      ( lineeditors_mark,
					"Lineeditors",
					gt::COL
					  [
					    lineeditor::with
					      {
						paneline  =>  1,
						textpane_id,
						textedit_id,
						options	    =>  [ le::DOC		"Lineeditor 1",
								  le::STATE		{ cursor => NULL, selected => NULL, text => "I am a lineeditor" },
								  le::PIXELS_HIGH_MIN	0
								]
					      }
					  ]
				      ),
				    gt::FRAME
				      ( [ gt::FRAME_WIDGET (frame::with [ frm::FRAME_RELIEF wt::RAISED ]) ],
					#
					statusline::with
					  {
					    textpane_id,
					    textedit_id,
					    options	=>  [ sl::DOC			"Statusline",
							      sl::TEXT			"I am a statusline",
							      sl::PIXELS_HIGH_MIN	16,
							      sl::PIXELS_HIGH_CUT	0.0
							    ]
					  }
				      )	
				  ]
			      )
			  ),

			minibuffer::with
			  {
			    textedit_id,
			    options =>  [ mb::DOC		"Minibuffer",
					  mb::TEXT		"I am a minibuffer",
					  mb::PIXELS_HIGH_MIN	16,
					  mb::PIXELS_HIGH_CUT	0.0
					]
			  }
		      ]
		  ); 

	    };													# PUBLIC
    };
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
